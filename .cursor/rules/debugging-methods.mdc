
---
description: LLM debugging methods and system validation procedures for the Amalgam project
globs: ["**/*"]
alwaysApply: true
---

# LLM Debugging Methods for Amalgam Project

## Implementation Requirements for LLMs

### Mandatory Testing & Debugging Standards
**ALL new implementations by LLMs MUST follow these requirements:**

#### 1. Pre-Implementation Testing
- **Run `npm test` before starting** any new feature implementation
- **Document current system state** and identify any existing issues
- **Plan test coverage** for the new feature before writing code
- **Ensure existing functionality** remains intact
- **Check for known issues** (e.g., missing ui/animations.js)

#### 2. Implementation Testing Requirements
- **Create unit tests** for all new functions and classes
- **Add integration tests** for new features that interact with existing systems
- **Include error handling tests** for edge cases and failure scenarios
- **Test data validation** for any new data structures or JSON files
- **Verify TypeScript compilation** for all new .ts files
- **Add performance benchmarks** for computationally intensive operations
- **Include security validation** for user inputs and data sanitization
- **Test browser compatibility** for web-based features

#### 3. Post-Implementation Validation
- **Run full test suite** (`npm test`) after implementation
- **Verify no regressions** in existing functionality
- **Test new features** through web interface (`npm run test:web`)
- **Document any new debugging patterns** discovered during implementation
- **Validate performance impact** of new features
- **Test error recovery** and graceful degradation

#### 4. Debugging Tools Integration
- **Add console logging** for complex operations with `utils/logger.js`
- **Include debug mode** for new features when appropriate
- **Create debug HTML pages** for visual testing of new components
- **Add data inspection tools** for new data structures
- **Implement error simulation** tools for testing failure scenarios
- **Add performance monitoring** for critical operations

#### 5. Code Quality Standards
- **Follow existing patterns** in the codebase for consistency
- **Include JSDoc comments** for all new functions and classes
- **Maintain TypeScript definitions** alongside JavaScript implementations
- **Use proper error handling** with try-catch blocks where appropriate
- **Implement input validation** and sanitization
- **Add comprehensive error messages** for debugging

#### 6. File and Code Organization Standards
- **Follow established directory structure**:
  - `core/` - Core game logic and rules
  - `game/` - Game management and player logic
  - `ui/` - User interface and graphics
  - `utils/` - Utility functions and helpers
  - `data/` - Game data and configuration files
  - `tests/` - Test files organized by feature
- **Use consistent file naming conventions**:
  - Source files: `camelCase.js` and `camelCase.ts`
  - Test files: `[feature-name]-test.html`
  - Data files: `kebab-case.json`
- **Maintain module boundaries**:
  - Each module should have a single responsibility
  - Clear import/export interfaces
  - Minimal cross-module dependencies
- **Organize imports consistently**:
  - External libraries first
  - Internal modules grouped by directory
  - Relative imports for local files

#### 7. Advanced Testing Requirements
- **Integration Testing**: Test interactions between multiple components
- **Performance Testing**: Benchmark critical operations and data structures
- **Security Testing**: Validate input sanitization and data integrity
- **Error Simulation**: Test system behavior under failure conditions
- **Browser Compatibility**: Test across different browsers and devices
- **Accessibility Testing**: Ensure features are accessible to all users

## System Validation Protocol

### Primary Debugging Command
**Always run `npm test` first** when debugging issues or before making changes to validate system integrity.

### CLI Test Analysis
- **Use the CLI test output** for structured, token-efficient system analysis
- **Focus on the "🤖 LLM SUMMARY" section** for quick status assessment
- **Reference test percentages** for health assessment (100% = fully operational)
- **Check for known issues** like missing ui/animations.js

### Advanced Test Categories
- **Performance Tests**: Measure execution time and memory usage
- **Security Tests**: Validate input sanitization and data integrity
- **Integration Tests**: Test component interactions and data flow
- **Error Simulation**: Test system behavior under failure conditions
- **Browser Compatibility**: Test across different browsers and devices
- **Accessibility Tests**: Ensure features are accessible to all users

## Debugging Workflow

### Step 1: System Health Check
```bash
npm test
# or
node tests/run-tests.js
```

### Step 2: Analyze Test Results
- **Green indicators (✅)**: System components working correctly
- **Red indicators (❌)**: Issues requiring immediate attention
- **Yellow indicators (⚠️)**: Warnings that may need investigation
- **Overall percentage**: Quick health assessment

### Step 3: Follow Recommendations
Use the "🔧 RECOMMENDATIONS" section in test output for specific fixes.

### Step 4: Advanced Validation
```bash
# Performance testing
npm run test:performance

# Security validation
npm run test:security

# Integration testing
npm run test:integration

# Browser compatibility
npm run test:browser
```

## Test Categories & Issues

### File System Tests
- **Critical files**: board-data.json, piece-definitions.json, game rules
- **Core modules**: board.js, rules.js, graphics.js, gameManager.js
- **Common issue**: Missing ui/animations.js (only .d.ts exists)

### Data Integrity Tests
- **JSON structure validation**: Check for valid JSON syntax
- **Required fields**: Verify all expected fields exist in data files
- **Common issue**: Invalid JSON causing parsing errors

### Module Syntax Tests
- **Import/export validation**: Check ES6 module syntax
- **Function/class detection**: Verify proper code structure
- **Common issue**: Missing export statements or import errors

### Path Resolution Tests
- **Relative vs absolute paths**: Verify path resolution works
- **File existence**: Check if files can be found
- **Common issue**: Incorrect path references

### Game Initialization Tests
- **Class structure**: Verify GameManager class exists
- **Constructor validation**: Check for proper initialization
- **Canvas support**: Verify canvas handling code
- **Event handling**: Check for user interaction code

### TypeScript Compilation Tests
- **TypeScript files**: Verify .ts files exist alongside .js
- **tsconfig.json**: Check for proper TypeScript configuration
- **Common issue**: Missing TypeScript setup

### Performance Tests
- **Execution time**: Measure critical operation performance
- **Memory usage**: Monitor memory consumption patterns
- **Data structure efficiency**: Validate algorithm complexity
- **Rendering performance**: Test canvas and graphics performance

### Security Tests
- **Input validation**: Test user input sanitization
- **Data integrity**: Verify data structure validation
- **XSS prevention**: Test for cross-site scripting vulnerabilities
- **Data injection**: Test for malicious data injection

### Integration Tests
- **Component interactions**: Test how modules work together
- **Data flow**: Validate data passing between components
- **State management**: Test state consistency across components
- **Error propagation**: Test error handling across boundaries

## New Feature Testing Requirements

### Test File Structure
```
tests/
├── [feature-name]/
│   ├── [feature-name]-test.html
│   ├── [feature-name]-debug.html
│   ├── [feature-name]-data-inspector.html
│   ├── [feature-name]-performance.html
│   └── [feature-name]-security.html
├── json/
│   └── [feature-name]-json-test.html
├── integration/
│   └── [feature-name]-integration-test.html
├── performance/
│   └── [feature-name]-benchmark.html
└── security/
    └── [feature-name]-security-test.html
```

### Source Code Organization
```
project-root/
├── core/                    # Core game logic
│   ├── board.js            # Board management
│   ├── rules.js            # Game rules engine
│   └── types.js            # Core type definitions
├── game/                    # Game management
│   ├── gameManager.js      # Main game controller
│   ├── player.js           # Player logic
│   └── [new-feature].js    # New feature modules
├── ui/                      # User interface
│   ├── graphics.js         # Rendering and graphics
│   ├── interactions.js     # User interactions
│   └── [new-ui].js         # New UI components
├── utils/                   # Utilities and helpers
│   ├── helpers.js          # General helper functions
│   ├── logger.js           # Logging utilities
│   └── [new-utils].js      # New utility modules
├── data/                    # Game data and configuration
│   ├── board-data.json     # Board configuration
│   ├── piece-definitions.json # Piece definitions
│   └── [new-data].json     # New data files
└── tests/                   # Test files (see structure above)
```

### Module Integration Guidelines
- **Follow existing module patterns** when adding new features
- **Update related modules** when adding new functionality
- **Maintain backward compatibility** with existing interfaces
- **Document integration points** in module comments
- **Test integration** with existing modules

### Required Test Components
- **Unit tests**: Individual function/class testing
- **Integration tests**: Feature interaction testing
- **Data validation tests**: JSON structure and content validation
- **Error handling tests**: Edge cases and failure scenarios
- **Visual debugging**: HTML pages for visual component testing
- **Performance benchmarks**: Execution time and memory usage
- **Security validation**: Input sanitization and data integrity
- **Browser compatibility**: Cross-browser testing
- **Accessibility tests**: Screen reader and keyboard navigation

### Test Documentation Standards
- **Test purpose**: Clear description of what each test validates
- **Expected behavior**: Document expected outcomes
- **Debugging instructions**: How to troubleshoot test failures
- **Integration notes**: How tests fit into the overall system
- **Performance baselines**: Expected performance metrics
- **Security considerations**: Potential security implications

## Common Issues & Solutions

### Missing ui/animations.js
```bash
# Issue: Only ui/animations.d.ts exists
# Solution: Create ui/animations.js or remove references
# Impact: May cause web import errors
```

### JSON Structure Issues
```bash
# Issue: Invalid JSON causing parsing errors
# Solution: Validate JSON files for syntax errors
# Command: node -e "JSON.parse(require('fs').readFileSync('path/to/file.json'))"
```

### Path Resolution Problems
```bash
# Issue: Relative vs absolute path confusion
# Solution: Check path resolution in affected modules
# Verify: Both relative and absolute paths work correctly
```

### TypeScript Compilation Issues
```bash
# Issue: TypeScript files not compiled
# Solution: Run npm run build to compile TypeScript
# Verify: All .ts files have corresponding .js files
```

### Performance Issues
```bash
# Issue: Slow execution or high memory usage
# Solution: Profile code and optimize algorithms
# Tools: Use browser dev tools or Node.js profiler
```

### Security Vulnerabilities
```bash
# Issue: Unvalidated user input or data injection
# Solution: Implement proper input validation and sanitization
# Test: Use security testing tools and manual validation
```

## Web Testing Protocol

### Interactive Testing
```bash
npm run test:web
# Opens web interface at http://localhost:8080
```

### Navigation Structure
- **Start at**: `tests/unified-test-navigation.html` (Test Hub)
- **Use auto-copy buttons**: For LLM-friendly result extraction
- **Navigation**: All test pages link back to Test Hub

### Advanced Web Testing
- **Performance profiling**: Use browser dev tools for performance analysis
- **Security testing**: Test for XSS and injection vulnerabilities
- **Accessibility testing**: Use screen readers and keyboard navigation
- **Cross-browser testing**: Test in multiple browsers and devices

## LLM-Optimized Output

### Token-Efficient Analysis
- **Focus on summary sections**: "🤖 LLM SUMMARY" and "🔧 RECOMMENDATIONS"
- **Use percentage scores**: Quick health assessment
- **Reference specific test categories**: For targeted debugging

### Structured Problem Diagnosis
- **System Status**: FULLY OPERATIONAL vs ISSUES DETECTED
- **Specific issue identification**: File System, Data Integrity, etc.
- **Actionable recommendations**: Step-by-step fix instructions
- **Performance metrics**: Execution time and memory usage
- **Security status**: Vulnerability assessment and recommendations

## Pre-Change Validation

### Before Making Changes
1. **Run `npm test`** to establish baseline
2. **Note any existing issues** in the system
3. **Plan changes** based on current system state
4. **Validate changes** by running tests again
5. **Check performance impact** of proposed changes
6. **Assess security implications** of new features

### After Making Changes
1. **Run `npm test`** to verify changes didn't break anything
2. **Check for new issues** introduced by changes
3. **Follow recommendations** if issues are found
4. **Document any new patterns** discovered
5. **Validate performance** of new implementations
6. **Test security** of new features

## Emergency Debugging

### Quick Health Check
```bash
# Fast system validation
npm test | grep -A 10 "LLM SUMMARY"
```

### Critical Issue Detection
```bash
# Check for critical failures
npm test | grep -E "(❌|FAILED|ERROR)"
```

### Performance Issues
```bash
# Check for performance problems
npm run test:performance
# or use browser dev tools for profiling
```

### Security Issues
```bash
# Check for security vulnerabilities
npm run test:security
# or use security scanning tools
```

### Web Interface Validation
```bash
# Start web server for interactive debugging
npm run test:web
# Navigate to: http://localhost:8080/tests/unified-test-navigation.html
```

## Best Practices

### For LLMs
- **Always start with `npm test`** when debugging
- **Use structured output** for analysis
- **Follow the recommendations** provided
- **Validate changes** before and after modifications
- **Create comprehensive tests** for all new features
- **Document debugging procedures** for new implementations
- **Consider performance implications** of all changes
- **Validate security** of new features and data handling

### For Developers
- **Run tests regularly** to catch issues early
- **Use web interface** for interactive debugging
- **Keep test suite updated** as new features are added
- **Document new debugging patterns** discovered
- **Maintain test coverage** for all critical functionality
- **Monitor performance** of critical operations
- **Regular security audits** of data handling and user inputs
- **Cross-browser testing** for web-based features

## Integration with Cursor

### Automatic Validation
- **Run tests before major changes**
- **Use test output for context** in code generation
- **Reference test results** in explanations
- **Validate generated code** against test suite
- **Check performance impact** of generated code
- **Validate security** of generated implementations

### Context Awareness
- **Understand current system state** before making changes
- **Use test categories** to focus debugging efforts
- **Leverage structured output** for efficient problem-solving
- **Follow established patterns** for consistent debugging
- **Consider performance implications** of all changes
- **Validate security** of all data handling

## Implementation Checklist for LLMs

### Before Starting Implementation
- [ ] Run `npm test` to establish baseline
- [ ] Review existing test patterns and structure
- [ ] Plan test coverage for new feature
- [ ] Identify integration points with existing code
- [ ] Assess performance implications
- [ ] Plan security validation approach
- [ ] Review directory structure and file organization
- [ ] Plan module boundaries and responsibilities
- [ ] Identify file naming conventions to follow

### During Implementation
- [ ] Write unit tests alongside feature code
- [ ] Include error handling and edge cases
- [ ] Add console logging for debugging
- [ ] Create debug HTML pages for visual testing
- [ ] Maintain TypeScript definitions
- [ ] Implement performance monitoring
- [ ] Add security validation and input sanitization
- [ ] Test browser compatibility
- [ ] Follow established directory structure
- [ ] Use consistent file naming conventions
- [ ] Maintain clear module boundaries
- [ ] Organize imports consistently
- [ ] Document integration points

### After Implementation
- [ ] Run full test suite (`npm test`)
- [ ] Test through web interface (`npm run test:web`)
- [ ] Verify no regressions in existing functionality
- [ ] Document new debugging procedures
- [ ] Update test navigation if needed
- [ ] Validate performance impact
- [ ] Test security of new features
- [ ] Verify cross-browser compatibility

### Quality Assurance
- [ ] All new functions have unit tests
- [ ] Integration tests cover feature interactions
- [ ] Error handling is properly tested
- [ ] Data validation is comprehensive
- [ ] Debug tools are available for troubleshooting
- [ ] Performance benchmarks are established
- [ ] Security validation is comprehensive
- [ ] Browser compatibility is verified
- [ ] Accessibility requirements are met
- [ ] File organization follows established patterns
- [ ] Module boundaries are clearly defined
- [ ] Import/export structure is consistent
- [ ] Integration with existing modules is tested

## Advanced Testing Framework

### Performance Testing
```bash
# Add to package.json scripts
"test:performance": "node tests/performance-runner.js",
"benchmark": "node tests/benchmark-runner.js"
```

### Security Testing
```bash
# Add to package.json scripts
"test:security": "node tests/security-runner.js",
"security:audit": "npm audit && node tests/security-audit.js"
```

### Integration Testing
```bash
# Add to package.json scripts
"test:integration": "node tests/integration-runner.js",
"test:e2e": "node tests/e2e-runner.js"
```

### Coverage Reporting
```bash
# Add to package.json scripts
"test:coverage": "node tests/coverage-runner.js",
"coverage:report": "open coverage/index.html"
```

## Future-Proofing Considerations

### Scalability Testing
- **Load testing**: Test system behavior under high load
- **Stress testing**: Test system limits and failure points
- **Scalability validation**: Ensure system can handle growth

### Maintenance Testing
- **Regression testing**: Ensure changes don't break existing functionality
- **Compatibility testing**: Test with different versions and environments
- **Migration testing**: Test data migration and system updates

### Monitoring and Alerting
- **Performance monitoring**: Track system performance over time
- **Error tracking**: Monitor and alert on system errors
- **Health checks**: Automated system health validation
