<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="no-referrer">
    <title>HSK 3.0 Chinese Vocabulary Game</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --reseda-green: #797d62ff;
            --moss-green: #9b9b7aff;
            --desert-sand: #d9ae94ff;
            --peach-yellow: #f1dca7ff;
            --sunglow: #ffcb69ff;
            --persian-orange: #d08c60ff;
            --beaver: #997b66ff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, var(--reseda-green), var(--moss-green));
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Landing Page */
        .landing-page {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            color: white;
            text-align: center;
            padding: 20px;
        }

        .landing-page h1 {
            font-size: 3rem;
            margin-bottom: 2rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            color: var(--peach-yellow);
        }

        .selection-container {
            background: rgba(255,255,255,0.15);
            padding: 0;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(31,38,135,0.37);
            border: 1px solid rgba(255,255,255,0.18);
            margin-bottom: 20px;
            overflow: hidden;
        }

        .config-section {
            padding: 25px 30px;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }

        .config-section:last-child {
            border-bottom: none;
        }

        .config-section h3 {
            font-size: 1.3rem;
            color: var(--peach-yellow);
            margin-bottom: 15px;
            text-align: center;
            font-weight: bold;
        }

        .config-section.band-section {
            background: linear-gradient(45deg, rgba(255,203,105,0.1), rgba(208,140,96,0.1));
        }

        .config-section.range-section {
            background: linear-gradient(45deg, rgba(217,174,148,0.1), rgba(241,220,167,0.1));
        }

        .config-section.options-section {
            background: linear-gradient(45deg, rgba(155,155,122,0.1), rgba(121,125,98,0.1));
        }

        .config-section.controls-section {
            background: linear-gradient(45deg, rgba(153,123,102,0.1), rgba(121,125,98,0.1));
        }

        .slider-container {
            margin: 0;
        }

        .slider-container label {
            display: block;
            margin-bottom: 10px;
            font-size: 1rem;
            color: white;
        }

        /* New Range Input Styling */
        .range-input-container {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 20px 0;
            justify-content: center;
            flex-wrap: wrap;
        }

        .range-input-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .range-input-group label {
            font-size: 0.9rem;
            color: var(--peach-yellow);
            margin-bottom: 0;
        }

        .range-input {
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 1rem;
            color: white;
            text-align: center;
            width: 80px;
            transition: all 0.3s ease;
        }

        .range-input:focus {
            outline: none;
            border-color: var(--sunglow);
            background: rgba(255,255,255,0.3);
        }

        .range-input::placeholder {
            color: rgba(255,255,255,0.7);
        }

        .range-separator {
            font-size: 1.2rem;
            color: var(--peach-yellow);
            font-weight: bold;
        }

        .range-values {
            margin: 10px 0;
            font-size: 1.1rem;
            color: var(--sunglow);
        }

        .range-progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(255,255,255,0.2);
            border-radius: 10px;
            margin: 15px 0;
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .range-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--sunglow), var(--persian-orange));
            border-radius: 10px;
            transition: all 0.3s ease;
            position: relative;
        }

        .range-progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.8rem;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
            z-index: 2;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 10px;
            justify-content: center;
        }

        .checkbox-container label {
            font-size: 1rem;
            color: white;
            cursor: pointer;
        }

        .tier-dropdown {
            background: rgba(255,255,255,0.2);
            color: white;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 1rem;
            cursor: pointer;
            transition: border-color 0.3s ease;
        }

        .tier-dropdown:focus {
            outline: none;
            border-color: var(--sunglow);
        }

        .tier-dropdown option {
            background: var(--beaver);
            color: white;
        }

        .game-options-grid {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 20px;
            align-items: center;
            width: 100%;
        }

        .option-divider {
            width: 2px;
            height: 60px;
            background: linear-gradient(180deg, transparent, rgba(255,255,255,0.3), transparent);
            border-radius: 2px;
        }

        .tier-select {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .tier-select label {
            font-size: 1rem;
            color: white;
        }

        .custom-checkbox {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 4px;
            background: rgba(255,255,255,0.2);
            cursor: pointer;
            position: relative;
            transition: all 0.3s ease;
        }

        .custom-checkbox.checked {
            background: var(--sunglow);
            border-color: var(--sunglow);
        }

        .custom-checkbox.checked::after {
            content: '‚úì';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 14px;
        }

        .start-button {
            background: linear-gradient(45deg, var(--persian-orange), var(--beaver));
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2rem;
            border-radius: 12px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .start-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
            background: linear-gradient(45deg, var(--sunglow), var(--persian-orange));
        }

        /* Game Page */
        .game-page {
            display: none;
            height: 100vh;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }

        .score-bar {
            background: linear-gradient(90deg, var(--reseda-green), var(--beaver));
            color: white;
            padding: 15px;
            text-align: center;
            font-size: 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .menu-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .mobile-menu-toggle {
            display: none;
            background: rgba(255,255,255,0.2);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.2rem;
        }

        .mobile-menu {
            display: none;
            position: absolute;
            top: 100%;
            left: 10px;
            right: 10px;
            background: rgba(0,0,0,0.95);
            border-radius: 10px;
            padding: 15px;
            z-index: 1000;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
        }

        .mobile-menu.active {
            display: block;
        }

        .mobile-menu-content {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .mobile-menu-row {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: space-between;
        }

        .stars-counter {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            flex: 1;
            font-size: 1.8rem;
            color: var(--sunglow);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .menu-btn {
            background: rgba(255,255,255,0.2);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .menu-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-1px);
        }

        .menu-btn.exit {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            border: 1px solid rgba(255,107,107,0.8);
        }

        .menu-btn.exit:hover {
            background: linear-gradient(45deg, #ff5252, #d32f2f);
        }

        .toggle-container {
            display: flex;
            align-items: center;
            gap: 8px;
            position: relative;
        }

        .info-icon {
            width: 16px;
            height: 16px;
            background: var(--peach-yellow);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: var(--beaver);
            cursor: help;
            position: relative;
        }

        .info-tooltip {
            position: absolute;
            bottom: 120%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.75rem;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
            z-index: 1001;
        }

        .info-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 6px solid rgba(0,0,0,0.9);
        }

        .info-icon:hover .info-tooltip {
            opacity: 1;
            visibility: visible;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 25px;
            background: rgba(255,255,255,0.3);
            border-radius: 25px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: var(--sunglow);
        }

        .toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 21px;
            height: 21px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .toggle-switch.active .toggle-slider {
            transform: translateX(25px);
        }

        .toggle-label {
            font-size: 0.8rem;
            color: white;
        }

        /* Settings Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: linear-gradient(135deg, var(--reseda-green), var(--moss-green));
            margin: 10% auto;
            padding: 30px;
            border-radius: 20px;
            width: 80%;
            max-width: 500px;
            color: white;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .modal h2 {
            margin-bottom: 20px;
            text-align: center;
            color: var(--peach-yellow);
        }

        .hotkey-setting {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            padding: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            font-size: 0.9rem;
        }

        .hotkey-input {
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.3);
            padding: 6px 10px;
            border-radius: 6px;
            color: white;
            width: 80px;
            text-align: center;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.8rem;
            transition: all 0.3s ease;
        }

        .hotkey-input:focus {
            border-color: var(--sunglow);
            background: rgba(255,255,255,0.3);
            outline: none;
        }

        .hotkey-input.listening {
            border-color: var(--persian-orange);
            background: rgba(255, 152, 0, 0.2);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .close-btn {
            background: linear-gradient(45deg, var(--persian-orange), var(--beaver));
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1rem;
            margin: 20px auto 0;
            display: block;
            transition: all 0.3s ease;
        }

        .close-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .star-icon {
            color: var(--sunglow);
            font-size: 1.8rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        /* Mascot Icon */
        .mascot-icon {
            position: fixed;
            width: 150px;
            height: 150px;
            opacity: 1;
            visibility: visible;
            transition: all 0.3s ease;
            z-index: 100;
            pointer-events: none;
        }

        .mascot-icon img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        #mascotImage {
            position: relative;
            top: -50px;
            left: 215px;
            width: 200px;
            height: 200px;
        }
        
        /* Chinese Characters Row */
        .characters-row {
            height: 240px;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(90deg, rgba(217,174,148,0.3), rgba(241,220,167,0.3));
            padding: 30px 0;
            border-bottom: 3px solid var(--desert-sand);
        }

        .character-container {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(145deg, rgba(255,255,255,0.95), rgba(241,220,167,0.9));
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            transition: all 0.5s ease;
            min-width: 120px;
            max-width: 200px;
            height: 150px;
            border: 3px solid transparent;
            padding: 10px;
            box-sizing: border-box;
        }

        .character-container.active {
            border-color: var(--sunglow);
            transform: scale(1.3);
            z-index: 10;
            box-shadow: 0 12px 30px rgba(255, 203, 105, 0.4);
            left: 50% !important;
            transform: translateX(-50%) scale(1.3);
            background: linear-gradient(145deg, rgba(255,203,105,0.9), rgba(241,220,167,0.95));
        }

        .character-container.next {
            transform: scale(1.0);
            opacity: 0.9;
            z-index: 5;
            border-color: var(--desert-sand);
        }

        .character-container.upcoming {
            transform: scale(0.8);
            opacity: 0.7;
            z-index: 1;
            border-color: rgba(155,155,122,0.5);
        }

        .pinyin {
            font-size: 0.9rem;
            color: var(--beaver);
            margin-bottom: 5px;
            text-align: center;
            word-wrap: break-word;
            font-weight: 500;
        }

        .chinese-char {
            font-size: 2rem;
            font-weight: bold;
            color: var(--reseda-green);
            text-align: center;
            word-wrap: break-word;
            line-height: 1.2;
        }

        .character-container.active .chinese-char {
            font-size: 2.5rem;
            color: var(--beaver);
        }

        /* English Options Grid */
        .options-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            background: linear-gradient(180deg, rgba(155,155,122,0.1), rgba(121,125,98,0.1));
        }

        .options-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 15px;
            width: min(80vw, 800px);
            height: min(65vh, 520px);
        }

        .option-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: none;
            border-radius: 15px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            padding: 20px 15px;
            min-height: 100px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
        }

        .option-btn span {
            font-size: clamp(0.8rem, 2vw, 1.2rem);
            text-align: center;
            line-height: 1.2;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
            max-width: 100%;
        }

        .option-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.25);
        }

        /* Material Tiers */
        .tier-bronze {
            background: linear-gradient(145deg, var(--beaver), var(--reseda-green));
            border: 3px solid var(--moss-green);
        }

        .tier-silver {
            background: linear-gradient(145deg, var(--moss-green), var(--desert-sand));
            border: 3px solid var(--peach-yellow);
        }

        .tier-gold {
            background: linear-gradient(145deg, var(--sunglow), var(--persian-orange));
            border: 3px solid var(--sunglow);
            animation: goldGlow 2s ease-in-out infinite alternate;
        }

        @keyframes goldGlow {
            from { box-shadow: 0 6px 20px rgba(255, 203, 105, 0.4); }
            to { box-shadow: 0 8px 30px rgba(255, 203, 105, 0.6); }
        }

        .progress-bar {
            position: absolute;
            bottom: 5px;
            left: 10px;
            right: 10px;
            height: 12px;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--sunglow), var(--persian-orange));
            border-radius: 6px;
            transition: width 0.3s ease;
            position: relative;
        }

        .progress-count {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .hotkey {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(0,0,0,0.7);
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: bold;
            z-index: 10;
        }

        /* Animations */
        @keyframes correct {
            0% { transform: scale(1); }
            25% { transform: scale(1.1); background: var(--sunglow); box-shadow: 0 0 20px var(--sunglow); }
            50% { transform: scale(1.2) rotate(5deg); }
            75% { transform: scale(1.1) rotate(-5deg); }
            100% { transform: scale(1) rotate(0deg); }
        }

        @keyframes shake {
            0% { transform: translateX(0) rotate(0deg); }
            10% { transform: translateX(-8px) rotate(-3deg); }
            20% { transform: translateX(8px) rotate(3deg); }
            30% { transform: translateX(-6px) rotate(-2deg); }
            40% { transform: translateX(6px) rotate(2deg); }
            50% { transform: translateX(-4px) rotate(-1deg); }
            60% { transform: translateX(4px) rotate(1deg); }
            70% { transform: translateX(-2px) rotate(-0.5deg); }
            80% { transform: translateX(2px) rotate(0.5deg); }
            90% { transform: translateX(-1px) rotate(-0.25deg); }
            100% { transform: translateX(0) rotate(0deg); }
        }

        @keyframes slideLeft {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(-200px); opacity: 0; }
        }

        @keyframes floatUp {
            from { 
                transform: translateY(0) scale(1); 
                opacity: 1; 
            }
            to { 
                transform: translateY(-50px) scale(1.2); 
                opacity: 0; 
            }
        }

        @keyframes newWordEntry {
            0% { 
                transform: scale(0) rotateY(90deg); 
                opacity: 0; 
            }
            50% { 
                transform: scale(1.1) rotateY(0deg); 
                opacity: 1; 
            }
            100% { 
                transform: scale(1) rotateY(0deg); 
                opacity: 1; 
            }
        }

        @keyframes tierUp {
            0% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.2) rotate(10deg); box-shadow: 0 0 30px currentColor; }
            100% { transform: scale(1) rotate(0deg); }
        }

        @keyframes starShoot {
            0% { 
                transform: scale(0) rotate(0deg); 
                opacity: 0; 
                color: var(--sunglow);
            }
            30% { 
                transform: scale(1.5) rotate(180deg); 
                opacity: 1; 
                color: var(--sunglow);
                text-shadow: 0 0 20px var(--sunglow);
            }
            70% { 
                transform: scale(2) rotate(360deg) translateY(-30px); 
                opacity: 1; 
                color: var(--persian-orange);
                text-shadow: 0 0 30px var(--sunglow);
            }
            100% { 
                transform: scale(1) rotate(540deg) translateY(0px); 
                opacity: 1; 
                color: var(--sunglow);
            }
        }

        .correct-animation {
            animation: correct 0.8s ease;
        }

        .shake-animation {
            animation: shake 0.8s ease;
        }

        .slide-left {
            animation: slideLeft 0.5s ease;
        }

        .float-up {
            animation: floatUp 1s ease;
        }

        .new-word-entry {
            animation: newWordEntry 0.8s ease;
        }

        .tier-up {
            animation: tierUp 0.8s ease;
        }

        .star-shoot {
            animation: starShoot 1.2s ease;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .score-bar {
                font-size: 1.2rem;
                padding: 10px;
            }

            .menu-controls {
                display: none;
            }

            .mobile-menu-toggle {
                display: block;
            }

            .stars-counter {
                font-size: 1.5rem;
            }

            .star-icon {
                font-size: 1.3rem;
            }

            /* Mobile character positioning and mascot */
            .characters-row {
                height: 200px;
                padding: 15px 10px;
            }

            .mascot-icon {
                right: 10px;
                height: 70%;
            }

            .character-container {
                min-width: 90px;
                max-width: 130px;
                height: 110px;
                padding: 8px;
            }

            .character-container.active {
                transform: translateX(-50%) scale(1.1);
                z-index: 100;
            }

            .character-container.next {
                transform: scale(0.8);
                opacity: 0.8;
                z-index: 5;
            }

            .character-container.upcoming {
                transform: scale(0.6);
                opacity: 0.6;
                z-index: 1;
            }

            .pinyin {
                font-size: 0.8rem;
            }

            .chinese-char {
                font-size: 1.5rem;
            }

            .character-container.active .chinese-char {
                font-size: 1.8rem;
            }

            .options-grid {
                width: 90vw;
                height: 400px;
                gap: 10px;
            }
            
            .option-btn {
                font-size: 0.9rem;
                padding: 15px 10px;
                min-height: 80px;
                aspect-ratio: 1.2;
            }
            
            /* Landing page mobile */
            .landing-page {
                padding: 10px;
                min-height: 100vh;
            }

            .landing-page h1 {
                font-size: 2rem;
                margin-bottom: 1.5rem;
            }

            .selection-container {
                padding: 20px;
                margin-bottom: 15px;
                width: 100%;
                max-width: 90vw;
            }

            .range-input-container {
                gap: 10px;
            }

            .range-input {
                width: 70px;
                padding: 6px 8px;
                font-size: 0.9rem;
            }

            .slider-container {
                margin: 15px 0;
            }

            .slider-container label {
                font-size: 1rem;
                margin-bottom: 8px;
            }

            .range-values {
                font-size: 1rem;
            }

            .tier-select {
                margin: 15px 0;
            }

            .tier-select label {
                font-size: 1rem;
            }

            .tier-dropdown {
                padding: 6px 10px;
                font-size: 0.9rem;
                width: 100%;
                max-width: 200px;
            }

            .start-button {
                padding: 12px 25px;
                font-size: 1rem;
                margin: 8px;
                width: calc(100% - 16px);
                max-width: 300px;
            }

            .modal-content {
                width: 95%;
                max-width: none;
                margin: 5% auto;
                padding: 20px;
            }

            .hotkey-setting {
                margin: 8px 0;
                padding: 6px;
                font-size: 0.8rem;
            }

            .hotkey-input {
                width: 60px;
                padding: 4px 6px;
                font-size: 0.7rem;
            }

            .toggle-container {
                flex-direction: column;
                gap: 4px;
                align-items: center;
            }

            .toggle-label {
                font-size: 0.7rem;
            }

            .toggle-switch {
                width: 40px;
                height: 20px;
            }

            .toggle-slider {
                width: 16px;
                height: 16px;
                top: 2px;
                left: 2px;
            }

            .toggle-switch.active .toggle-slider {
                transform: translateX(20px);
            }

            /* Mobile mascot and hotkey adjustments */
            .mascot-icon {
                width: 110px;
                height: 110px;
            }

            .hotkey {
                width: 18px;
                height: 18px;
                font-size: 0.6rem;
                top: 3px;
                right: 3px;
            }
        }
    </style>
</head>
<body>
    <!-- Landing Page -->
    <div class="landing-page" id="landingPage">
        <h1>HSK 3.0 Chinese Vocabulary</h1>
        <div class="selection-container">
            <!-- Band Selection Section -->
            <div class="config-section band-section">
                <h3>üìö Select HSK Band</h3>
                <div class="slider-container">
                    <select class="tier-dropdown" id="bandSelector" onchange="changeBand()">
                        <option value="1" selected>Band 1</option>
                        <option value="2">Band 2</option>
                        <option value="3">Band 3</option>
                    </select>
                </div>
            </div>

            <!-- Word Range Section -->
            <div class="config-section range-section">
                <h3>üéØ Select Word Range</h3>
                <div class="slider-container">
                    <div class="range-input-container">
                        <div class="range-input-group">
                            <label>From:</label>
                            <input type="number" id="startInput" class="range-input" min="1" max="50" value="1" onchange="updateRange()" oninput="updateRange()">
                        </div>
                        <span class="range-separator">‚Äî</span>
                        <div class="range-input-group">
                            <label>To:</label>
                            <input type="number" id="endInput" class="range-input" min="1" max="50" value="50" onchange="updateRange()" oninput="updateRange()">
                        </div>
                    </div>
                    <div class="range-values">
                        Words: <span id="startValue">1</span> - <span id="endValue">50</span>
                        (<span id="totalWords">50</span> total)
                    </div>
                    <div class="range-progress-bar">
                        <div class="range-progress-fill" id="rangeProgressFill"></div>
                        <div class="range-progress-text" id="rangeProgressText">50 / 500 words</div>
                    </div>
                </div>
            </div>

            <!-- Game Options Section -->
            <div class="config-section options-section">
                <h3>‚öôÔ∏è Game Options</h3>
                <div class="game-options-grid">
                    <div class="option-item">
                        <div class="checkbox-container">
                            <div class="custom-checkbox" id="randomizeCheckbox" onclick="toggleRandomize()"></div>
                            <label for="randomizeCheckbox" onclick="toggleRandomize()">Randomize word order</label>
                        </div>
                    </div>
                    
                    <div class="option-divider"></div>
                    
                    <div class="option-item">
                        <div class="tier-select">
                            <label>Correct answers per tier:</label>
                            <select class="tier-dropdown" id="landingTierRequirement">
                                <option value="1">1</option>
                                <option value="2">2</option>
                                <option value="3" selected>3</option>
                                <option value="4">4</option>
                                <option value="5">5</option>
                                <option value="6">6</option>
                                <option value="7">7</option>
                                <option value="8">8</option>
                                <option value="9">9</option>
                                <option value="10">10</option>
                                <option value="11">11</option>
                                <option value="12">12</option>
                                <option value="13">13</option>
                                <option value="14">14</option>
                                <option value="15">15</option>
                                <option value="16">16</option>
                                <option value="17">17</option>
                                <option value="18">18</option>
                                <option value="19">19</option>
                                <option value="20">20</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Start Game Section -->
            <div class="config-section controls-section">
                <h3>üöÄ Start Game</h3>
                <button class="start-button" onclick="startGame(false)">Custom Selection</button>
                <button class="start-button" onclick="startGame(true)" id="allWordsButton">All Words in Band</button>
            </div>
        </div>
    </div>

    <!-- Game Page -->
    <div class="game-page" id="gamePage">
        <div class="score-bar">
            <!-- Desktop menu controls -->
            <div class="menu-controls">
                <button class="menu-btn exit" onclick="returnToMenu()">‚Üê Menu</button>
                <button class="menu-btn" onclick="openSettings()">Hotkeys</button>
                <div class="toggle-container">
                    <span class="toggle-label">Easy Mode</span>
                    <div class="toggle-switch" id="easyModeToggle" onclick="toggleEasyMode()">
                        <div class="toggle-slider"></div>
                    </div>
                    <div class="info-icon">
                        i
                        <div class="info-tooltip">Prevents losing tiers on wrong answers</div>
                    </div>
                </div>
                <div class="toggle-container">
                    <span class="toggle-label">Traditional</span>
                    <div class="toggle-switch" id="traditionalToggle" onclick="toggleTraditional()">
                        <div class="toggle-slider"></div>
                    </div>
                    <div class="info-icon">
                        i
                        <div class="info-tooltip">Simplified vs Traditional characters</div>
                    </div>
                </div>
            </div>

            <!-- Mobile menu toggle -->
            <button class="mobile-menu-toggle" onclick="toggleMobileMenu()">‚ò∞</button>

            <!-- Stars counter (centered) -->
            <div class="stars-counter">
                <span class="star-icon" id="starIcon">‚≠ê</span>
                <span id="starsCount">0</span> / <span id="totalStarsCount">0</span>
            </div>

            <!-- Mobile collapsible menu -->
            <div class="mobile-menu" id="mobileMenu">
                <div class="mobile-menu-content">
                    <div class="mobile-menu-row">
                        <button class="menu-btn exit" onclick="returnToMenu()">‚Üê Menu</button>
                        <button class="menu-btn" onclick="openSettings()">Hotkeys</button>
                    </div>
                    <div class="mobile-menu-row">
                        <div class="toggle-container">
                            <span class="toggle-label">Easy Mode</span>
                            <div class="toggle-switch" id="easyModeToggleMobile" onclick="toggleEasyMode()">
                                <div class="toggle-slider"></div>
                            </div>
                        </div>
                        <div class="toggle-container">
                            <span class="toggle-label">Traditional</span>
                            <div class="toggle-switch" id="traditionalToggleMobile" onclick="toggleTraditional()">
                                <div class="toggle-slider"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="characters-row" id="charactersRow">
            <!-- Mascot container - independent styling, no inherited classes -->
            <div class="mascot-container" id="mascotContainer">
                <img id="mascotImage" src="Mascot/idle.gif" alt="Mascot" />
            </div>
        </div>
        
        <div class="options-container">
            <div class="options-grid" id="optionsGrid"></div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <h2>Hotkey Settings</h2>
            <div id="hotkeySettings"></div>
            <button class="close-btn" onclick="closeSettings()">Save & Close</button>
        </div>
    </div>

    <!-- Load HSK Word Data Files -->
    <script src="wordlists/band-1-words.js"></script>
    <script src="wordlists/band-2-words.js"></script>
    <script src="wordlists/band-3-words.js"></script>

    <script>
        // HSK Words - loaded from separate JS files
        const hskBands = {
            1: typeof hskBand1 !== 'undefined' ? hskBand1 : [],
            2: typeof hskBand2 !== 'undefined' ? hskBand2 : [],
            3: typeof hskBand3 !== 'undefined' ? hskBand3 : []
        };

        let hskWords = [];
        let currentBand = 1;
        let useTraditional = false; // Toggle for traditional characters
        let randomizeWords = false; // Toggle for randomized word order

        // Load HSK words from embedded data
        function loadHSKWords(band = 1) {
            try {
                if (hskBands[band] && hskBands[band].length > 0) {
                    hskWords = hskBands[band];
                    console.log(`Loaded ${hskWords.length} words from HSK Band ${band}`);
                    
                    // Update button text to show correct range
                    const allWordsButton = document.getElementById('allWordsButton');
                    if (allWordsButton) {
                        allWordsButton.textContent = `All Words (Band ${band})`;
                    }
                    
                    // Update input max values based on loaded words
                    const maxWords = hskWords.length;
                    document.getElementById('startInput').max = maxWords;
                    document.getElementById('endInput').max = maxWords;
                    document.getElementById('endInput').value = Math.min(50, maxWords);
                    updateRange();
                    
                    return true;
                } else {
                    throw new Error(`Band ${band} not available or empty`);
                }
            } catch (error) {
                console.error('Failed to load HSK words:', error);
                // Fallback to Band 1 if other bands fail
                hskWords = hskBands[1] || [];
                console.log('Using fallback wordlist');
                return false;
            }
        }

        // Helper function to get Chinese character (simplified or traditional)
        function getChineseChar(word) {
            return useTraditional && word.traditional ? word.traditional : word.chinese;
        }

        // WORKING Google TTS implementation based on research
        function playPronunciation(text) {
            if (!text) return;
            
            try {
                // Method from working examples - simple audio element approach
                const audio = new Audio();
                
                // Use the proven working URL format from research
                // Format: https://translate.google.com/translate_tts?tl=LANG&q=TEXT&client=tw-ob
                const ttsUrl = `https://translate.google.com/translate_tts?tl=zh-CN&q=${encodeURIComponent(text)}&client=tw-ob`;
                
                console.log('Playing TTS for:', text);
                console.log('TTS URL:', ttsUrl);
                
                audio.src = ttsUrl;
                
                // Handle errors
                audio.onerror = function(e) {
                    console.log('Primary audio method failed, trying alternative...');
                    playTTSAlternative(text);
                };
                
                // Handle successful loading
                audio.oncanplaythrough = function() {
                    console.log('Audio loaded successfully, playing...');
                };
                
                // Play the audio
                audio.play().catch(err => {
                    console.log('Audio play failed:', err);
                    playTTSAlternative(text);
                });
                
            } catch (error) {
                console.log('TTS creation failed:', error);
                playTTSAlternative(text);
            }
        }

        // Alternative method using embedded audio element
        function playTTSAlternative(text) {
            try {
                console.log('Trying alternative TTS method...');
                
                // Create or reuse hidden audio element
                let audioElement = document.getElementById('tts-audio-element');
                if (!audioElement) {
                    audioElement = document.createElement('audio');
                    audioElement.id = 'tts-audio-element';
                    audioElement.style.display = 'none';
                    audioElement.preload = 'none';
                    document.body.appendChild(audioElement);
                }
                
                // Use alternative URL format with more parameters
                const ttsUrl = `https://translate.google.com/translate_tts?ie=UTF-8&total=1&idx=0&textlen=${text.length}&client=tw-ob&q=${encodeURIComponent(text)}&tl=zh-CN`;
                
                console.log('Alternative TTS URL:', ttsUrl);
                
                audioElement.src = ttsUrl;
                audioElement.load();
                
                audioElement.oncanplaythrough = function() {
                    console.log('Alternative audio loaded, playing...');
                    audioElement.play().catch(err => {
                        console.log('Alternative audio play failed:', err);
                        playTTSFinalFallback(text);
                    });
                };
                
                audioElement.onerror = function(e) {
                    console.log('Alternative audio failed:', e);
                    playTTSFinalFallback(text);
                };
                
            } catch (error) {
                console.log('Alternative TTS failed:', error);
                playTTSFinalFallback(text);
            }
        }

        // Final fallback: create audio element in a more direct way
        function playTTSFinalFallback(text) {
            try {
                console.log('Trying final TTS fallback...');
                
                // Most basic approach - just create audio and play
                const ttsUrl = `https://translate.google.com/translate_tts?tl=zh-CN&q=${encodeURIComponent(text)}&client=tw-ob`;
                
                // Create new audio element each time
                const audio = new Audio(ttsUrl);
                
                audio.addEventListener('loadeddata', function() {
                    console.log('Final fallback audio loaded');
                    audio.play().catch(err => {
                        console.log('Final fallback play failed:', err);
                        console.log('All TTS methods exhausted. You can test the URL directly:');
                        console.log(ttsUrl);
                    });
                });
                
                audio.addEventListener('error', function(e) {
                    console.log('Final fallback failed:', e);
                    console.log('Test this URL directly in browser:', ttsUrl);
                });
                
                // Try to load
                audio.load();
                
            } catch (error) {
                console.log('Final TTS fallback failed:', error);
            }
        }

        // Game State with mascot animations and queue
        let gameState = {
            selectedWords: [],
            currentWords: [],
            activeWordIndex: 0,
            wordProgress: {},
            starsEarned: 0,
            completedWords: 0,
            charactersOnScreen: [],
            optionButtons: [],
            currentOptions: [],
            hotkeys: ['7', '8', '9', '4', '5', '6', '1', '2', '3', '0'], // Default numpad layout
            streakCount: 0,
            lastAnswerTime: 0,
            alreadyPenalized: false,
            easyMode: false, // Toggle for tier demotion
            tierRequirement: 5, // How many correct answers needed to tier up
            mascotAnimations: {
                idle: 'Mascot/idle.gif',
                rally: 'Mascot/rally.gif',
                sad: 'Mascot/sad.gif',
                celebrate: 'Mascot/celebrate.gif',
                ouch: 'Mascot/ouch.gif'
            },
            mascotAnimationQueue: [],
            currentMascotAnimation: 'idle',
            mascotAnimationPlaying: false,
            sadAnimationActive: false // Track if sad animation is currently playing
        };

        // Sound Effects
        function playSound(type) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                let frequencies, duration;
                
                switch(type) {
                    case 'correct':
                        frequencies = [523, 659, 784]; // C, E, G chord
                        duration = 0.3;
                        break;
                    case 'incorrect':
                        frequencies = [196, 220]; // Dissonant low notes
                        duration = 0.5;
                        break;
                    case 'complete':
                        frequencies = [523, 659, 784, 1047]; // C major with high C
                        duration = 0.8;
                        break;
                    case 'tierUp':
                        frequencies = [440, 554, 659]; // A, C#, E - triumph chord
                        duration = 0.6;
                        break;
                    case 'starShoot':
                        frequencies = [523, 659, 784, 1047, 1319]; // Rising star sound
                        duration = 1.0;
                        break;
                    default:
                        frequencies = [440];
                        duration = 0.3;
                }
                
                frequencies.forEach((frequency, index) => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    oscillator.type = type === 'incorrect' ? 'sawtooth' : 'sine';
                    
                    const startTime = audioContext.currentTime + (index * 0.1);
                    gainNode.gain.setValueAtTime(0.2, startTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + duration);
                    
                    oscillator.start(startTime);
                    oscillator.stop(startTime + duration);
                });
            } catch (error) {
                console.log('Sound synthesis failed:', error);
            }
        }

        // Landing Page Logic
        function updateRange() {
            const startInput = document.getElementById('startInput');
            const endInput = document.getElementById('endInput');
            const maxWords = parseInt(startInput.max);
            
            let start = parseInt(startInput.value);
            let end = parseInt(endInput.value);
            
            // Validate and constrain inputs
            start = Math.max(1, Math.min(start, maxWords));
            end = Math.max(1, Math.min(end, maxWords));
            
            // Ensure start is not greater than end
            if (start > end) {
                end = start;
            }
            
            // Update input values if they were corrected
            startInput.value = start;
            endInput.value = end;
            
            const totalSelected = end - start + 1;
            
            // Update display values
            document.getElementById('startValue').textContent = start;
            document.getElementById('endValue').textContent = end;
            document.getElementById('totalWords').textContent = totalSelected;
            
            // Update progress bar
            const progressFill = document.getElementById('rangeProgressFill');
            const progressText = document.getElementById('rangeProgressText');
            
            if (progressFill && progressText) {
                const percentage = (totalSelected / maxWords) * 100;
                progressFill.style.width = `${percentage}%`;
                progressText.textContent = `${totalSelected} / ${maxWords} words`;
            }
        }

        function toggleRandomize() {
            randomizeWords = !randomizeWords;
            const checkbox = document.getElementById('randomizeCheckbox');
            
            if (randomizeWords) {
                checkbox.classList.add('checked');
            } else {
                checkbox.classList.remove('checked');
            }
        }

        function startGame(allWords) {
            // Check if words are loaded
            if (hskWords.length === 0) {
                alert('Please wait for the wordlist to load, then try again.');
                return;
            }
            
            let startIndex, endIndex;
            
            if (allWords) {
                startIndex = 1;
                endIndex = hskWords.length; // Use all available words
            } else {
                startIndex = parseInt(document.getElementById('startInput').value);
                endIndex = parseInt(document.getElementById('endInput').value);
            }
            
            // Get tier requirement from landing page
            gameState.tierRequirement = parseInt(document.getElementById('landingTierRequirement').value);
            
            // Select words for the game
            let selectedWords = hskWords.slice(startIndex - 1, endIndex);
            
            // Randomize if option is selected
            if (randomizeWords) {
                selectedWords = shuffleArray([...selectedWords]);
            }
            
            gameState.selectedWords = selectedWords;
            gameState.currentWords = gameState.selectedWords.slice(0, Math.min(10, gameState.selectedWords.length));
            
            // Initialize word progress - start with bronze
            gameState.wordProgress = {};
            gameState.selectedWords.forEach(word => {
                gameState.wordProgress[word.chinese] = { count: 0, tier: 'bronze' };
            });
            
            // Initialize game state
            gameState.starsEarned = 0;
            gameState.completedWords = 0;
            gameState.activeWordIndex = 0;
            gameState.charactersOnScreen = [];
            gameState.streakCount = 0;
            gameState.lastAnswerTime = 0;
            gameState.alreadyPenalized = false;
            gameState.sadAnimationActive = false;
            
            // Update UI
            document.getElementById('totalStarsCount').textContent = gameState.selectedWords.length;
            document.getElementById('starsCount').textContent = gameState.starsEarned;
            
            // Switch to game page
            document.getElementById('landingPage').style.display = 'none';
            document.getElementById('gamePage').style.display = 'flex';
            
            // Initialize game
            initializeGame();
        }

        // Fisher-Yates shuffle algorithm
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function initializeGame() {
            console.log('=== INITIALIZING FRESH GAME ===');
            
            // Ensure we start with completely clean state
            gameState.activeWordIndex = 0;
            gameState.charactersOnScreen = [];
            gameState.optionButtons = [];
            gameState.currentOptions = [];
            gameState.streakCount = 0;
            gameState.lastAnswerTime = 0;
            gameState.alreadyPenalized = false;
            
            console.log('Pre-setup state:', {
                activeWordIndex: gameState.activeWordIndex,
                charactersOnScreen: gameState.charactersOnScreen.length,
                currentWords: gameState.currentWords.length,
                selectedWords: gameState.selectedWords.length
            });
            
            // Initialize components in proper order
            setupCharactersRow();
            setupOptionsGrid();
            setupKeyboardListeners();
            
            // Verify state after setup
            console.log('Post-setup state:', {
                activeWordIndex: gameState.activeWordIndex,
                charactersOnScreen: gameState.charactersOnScreen.length,
                optionButtons: gameState.optionButtons.length,
                currentOptions: gameState.currentOptions.length
            });
            
            // Initialize mascot in idle state
            queueMascotAnimation('idle');
            
            console.log('=== GAME INITIALIZATION COMPLETE ===');
        }

        // Ensure mascot stays in idle when not animating
        function ensureMascotIdle() {
            // Only set to idle if no animations are queued or playing
            if (!gameState.mascotAnimationPlaying && gameState.mascotAnimationQueue.length === 0) {
                queueMascotAnimation('idle');
            }
        }

        function setupCharactersRow() {
            console.log('=== SETTING UP CHARACTERS ROW ===');
            
            const charactersRow = document.getElementById('charactersRow');
            
            // COMPLETE cleanup of existing characters (except mascot)
            const existingCharacters = charactersRow.querySelectorAll('.character-container:not(.mascot-container)');
            console.log('Removing existing characters:', existingCharacters.length);
            existingCharacters.forEach(char => {
                char.remove();
            });
            
            // ENSURE charactersOnScreen array is completely empty
            gameState.charactersOnScreen = [];
            
            // Verify we have current words to work with
            if (gameState.currentWords.length === 0) {
                console.error('No current words available for character setup!');
                return;
            }
            
            console.log('Available current words:', gameState.currentWords.length);
            
            // Create 8 fresh characters
            for (let i = 0; i < 8; i++) {
                const word = getRandomCurrentWord();
                const container = document.createElement('div');
                
                // Set initial class based on position
                if (i === 0) {
                    // First character is active (center)
                    container.className = 'character-container active';
                    // EXPLICITLY set the active word index to 0
                    gameState.activeWordIndex = 0;
                    console.log('Set active character:', word.chinese, word.english);
                    setTimeout(() => playPronunciation(getChineseChar(word)), 300);
                } else if (i <= 2) {
                    container.className = 'character-container next';
                } else {
                    container.className = 'character-container upcoming';
                }
                
                container.innerHTML = `
                    <div class="pinyin">${word.pinyin}</div>
                    <div class="chinese-char">${getChineseChar(word)}</div>
                `;
                
                // Calculate container width based on content
                const chineseText = getChineseChar(word);
                const estimatedWidth = Math.max(120, chineseText.length * 30 + 40);
                container.style.width = `${estimatedWidth}px`;
                
                charactersRow.appendChild(container);
                gameState.charactersOnScreen.push({ element: container, word: word, width: estimatedWidth });
            }
            
            // Position all containers with proper spacing
            positionCharacterContainers();
            
            console.log('Characters row setup complete:', {
                charactersOnScreen: gameState.charactersOnScreen.length,
                activeWordIndex: gameState.activeWordIndex,
                activeWord: gameState.charactersOnScreen[0]?.word.chinese
            });
        }

        function positionCharacterContainers() {
            if (gameState.charactersOnScreen.length === 0) return;
            
            const isMobile = window.innerWidth <= 768;
            const screenCenter = window.innerWidth / 2;
            let positions = []; // Array to store center positions
            
            // Start with the active character at exact screen center
            positions[0] = screenCenter;
            
            // Calculate positions from center outward (all characters trail to the LEFT)
            for (let i = 1; i < gameState.charactersOnScreen.length; i++) {
                const currentContainer = gameState.charactersOnScreen[i];
                const prevContainer = gameState.charactersOnScreen[i - 1];
                
                // Get base container widths
                const currentWidth = currentContainer.width;
                const prevWidth = prevContainer.width;
                
                let minDistance;
                if (isMobile) {
                    // Mobile: account for scaling and add generous spacing
                    if (i === 1) {
                        // Active (scale 1.1) to next (scale 0.8)
                        const activeScaledWidth = prevWidth * 1.1;
                        const nextScaledWidth = currentWidth * 0.8;
                        minDistance = (activeScaledWidth / 2) + (nextScaledWidth / 2) + 50; // Fixed large gap
                    } else if (i <= 2) {
                        // Next (scale 0.8) to upcoming (scale 0.6)
                        const nextScaledWidth = prevWidth * 0.8;
                        const upcomingScaledWidth = currentWidth * 0.8;
                        minDistance = (nextScaledWidth / 2) + (upcomingScaledWidth / 2) + 20;
                    } else {
                        // Upcoming characters (scale 0.6)
                        const prevScaledWidth = prevWidth * 0.6;
                        const currentScaledWidth = currentWidth * 0.6;
                        minDistance = (prevScaledWidth / 2) + (currentScaledWidth / 2) + 15;
                    }
                } else {
                    // Desktop: tighter, more precise spacing
                    if (i === 1) {
                        // Active (scale 1.3) to next (scale 1.0)
                        const activeScaledWidth = prevWidth * 1.3;
                        const nextWidth = currentWidth * 1.0;
                        minDistance = (activeScaledWidth / 2) + (nextWidth / 2) + 25;
                    } else {
                        // Subsequent characters
                        const prevScaledWidth = prevWidth * (i <= 2 ? 1.0 : 0.8);
                        const currentScaledWidth = currentWidth * (i <= 2 ? 1.0 : 0.8);
                        minDistance = (prevScaledWidth / 2) + (currentScaledWidth / 2) + 25;
                    }
                }
                
                // Always position to the LEFT (subtract from previous position)
                positions[i] = positions[i - 1] - minDistance;
            }
            
            // Apply positions and styling to character containers
            gameState.charactersOnScreen.forEach((char, index) => {
                const container = char.element;
                container.className = 'character-container';
                
                // Set position and base transform
                container.style.left = `${positions[index]}px`;
                container.style.transform = 'translateX(-50%)';
                
                if (index === 0) {
                    container.classList.add('active');
                    container.style.transform = isMobile ? 
                        'translateX(-50%) scale(1.1)' : 
                        'translateX(-50%) scale(1.3)';
                    container.style.zIndex = '100';
                    gameState.activeWordIndex = 0;
                } else if (index <= 2) {
                    container.classList.add('next');
                    container.style.transform = isMobile ? 
                        'translateX(-50%) scale(0.8)' : 
                        'translateX(-50%) scale(1.0)';
                    container.style.zIndex = '5';
                } else {
                    container.classList.add('upcoming');
                    container.style.transform = isMobile ? 
                        'translateX(-50%) scale(0.6)' : 
                        'translateX(-50%) scale(0.8)';
                    container.style.zIndex = '1';
                }
            });
            
            // Position mascot container to the RIGHT of active character with proper spacing
            const mascotContainer = document.getElementById('mascotContainer');
            if (mascotContainer && gameState.charactersOnScreen.length > 0) {
                // Calculate mascot position using the same distance logic as "next up" characters
                const activeContainer = gameState.charactersOnScreen[0];
                const activeWidth = activeContainer.width;
                const mascotWidth = 120; // Estimated mascot container width
                
                let mascotDistance;
                if (isMobile) {
                    // Same calculation as active to first next, but to the RIGHT
                    const activeScaledWidth = activeWidth * 1.1;
                    const mascotScaledWidth = mascotWidth * 1.1; // Scale like active character
                    mascotDistance = (activeScaledWidth / 2) + (mascotScaledWidth / 2) + 50;
                } else {
                    // Desktop calculation - same as "next up" but to the RIGHT
                    const activeScaledWidth = activeWidth * 1.3;
                    const mascotScaledWidth = mascotWidth * 1.3; // Scale like active character
                    mascotDistance = (activeScaledWidth / 2) + (mascotScaledWidth / 2) + 25;
                }
                
                // Position mascot to the RIGHT (ADD distance instead of subtract)
                const activePos = screenCenter;
                const mascotPos = activePos + mascotDistance;
                
                // Apply independent styling to mascot (no inherited classes)
                mascotContainer.className = 'mascot-container';
                mascotContainer.style.left = `${mascotPos}px`;
                mascotContainer.style.transform = isMobile ? 
                    'translateX(-50%) scale(1.1)' : 
                    'translateX(-50%) scale(1.3)';
                mascotContainer.style.zIndex = '200'; // Higher than active character
            }
        }

        function getRandomCurrentWord() {
            return gameState.currentWords[Math.floor(Math.random() * gameState.currentWords.length)];
        }

        function setupOptionsGrid() {
            console.log('=== SETTING UP OPTIONS GRID ===');
            
            const optionsGrid = document.getElementById('optionsGrid');
            
            // COMPLETE cleanup
            optionsGrid.innerHTML = '';
            gameState.optionButtons = [];
            gameState.currentOptions = [];
            
            console.log('Current words available for options:', gameState.currentWords.length);
            
            // Create 10 fresh option buttons
            for (let i = 0; i < 10; i++) {
                const word = i < gameState.currentWords.length ? gameState.currentWords[i] : null;
                const button = document.createElement('button');
                button.className = 'option-btn tier-bronze';
                
                if (word) {
                    const progress = gameState.wordProgress[word.chinese];
                    if (!progress) {
                        console.error('Missing progress for word:', word.chinese);
                        // Initialize progress if missing
                        gameState.wordProgress[word.chinese] = { count: 0, tier: 'bronze' };
                    }
                    
                    const currentProgress = gameState.wordProgress[word.chinese];
                    button.className = `option-btn tier-${currentProgress.tier}`;
                    
                    button.innerHTML = `
                        <span>${word.english}</span>
                        <div class="progress-count">${currentProgress.count}/${gameState.tierRequirement}</div>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${(currentProgress.count % gameState.tierRequirement) * (100/gameState.tierRequirement)}%"></div>
                        </div>
                        <div class="hotkey">${gameState.hotkeys[i]}</div>
                    `;
                    
                    // Create fresh event handler for this specific button
                    button.onclick = () => selectOption(i);
                    gameState.currentOptions[i] = word;
                    
                    console.log(`Option ${i}:`, word.chinese, word.english);
                } else {
                    button.innerHTML = `
                        <span>---</span>
                        <div class="hotkey">${gameState.hotkeys[i]}</div>
                    `;
                    button.style.opacity = '0.5';
                    gameState.currentOptions[i] = null;
                }
                
                optionsGrid.appendChild(button);
                gameState.optionButtons.push(button);
            }
            
            console.log('Options grid setup complete:', {
                optionButtons: gameState.optionButtons.length,
                currentOptions: gameState.currentOptions.filter(o => o !== null).length,
                firstOption: gameState.currentOptions[0]?.chinese
            });
        }

        function selectOption(optionIndex) {
            const selectedWord = gameState.currentOptions[optionIndex];
            const activeCharacter = gameState.charactersOnScreen[gameState.activeWordIndex];
            
            if (!selectedWord || !activeCharacter) return;
            
            const isCorrect = selectedWord.chinese === activeCharacter.word.chinese;
            const button = gameState.optionButtons[optionIndex];
            const currentTime = Date.now();
            
            if (isCorrect) {
                // Check for streak (fast answers)
                const timeDiff = currentTime - gameState.lastAnswerTime;
                if (timeDiff < 1000 && gameState.lastAnswerTime > 0) { // Less than 1 second
                    gameState.streakCount++;
                    updateMascotIcon();
                } else {
                    gameState.streakCount = 1; // Reset but count this one
                    updateMascotIcon();
                }
                gameState.lastAnswerTime = currentTime;
                
                handleCorrectAnswer(selectedWord, button, optionIndex);
                gameState.alreadyPenalized = false; // Reset penalty flag for new character
            } else {
                gameState.streakCount = 0; // Break streak on wrong answer
                updateMascotIcon();
                handleIncorrectAnswer(activeCharacter.word, optionIndex);
                highlightCorrectAnswer(activeCharacter.word);
            }
        }

        // Mascot animation functions with queue system
        function setMascotAnimation(animationType) {
            const mascotImage = document.getElementById('mascotImage');
            if (mascotImage && gameState.mascotAnimations[animationType]) {
                // Force reload of GIF to start from beginning
                const timestamp = new Date().getTime();
                mascotImage.src = gameState.mascotAnimations[animationType] + '?t=' + timestamp;
                gameState.currentMascotAnimation = animationType;
                
                // Track if sad animation is starting
                if (animationType === 'sad') {
                    gameState.sadAnimationActive = true;
                }
            }
        }

        function queueMascotAnimation(animationType) {
            if (animationType === 'idle') {
                // Idle can be set immediately if nothing is playing
                if (!gameState.mascotAnimationPlaying && gameState.mascotAnimationQueue.length === 0) {
                    setMascotAnimation('idle');
                }
                return;
            }

            // Block ALL animations (including additional sad) if sad is active
            if (gameState.sadAnimationActive) {
                console.log(`Blocking ${animationType} animation because sad animation is active`);
                return;
            }

            // Add to queue if it's not idle
            gameState.mascotAnimationQueue.push(animationType);
            processAnimationQueue();
        }

        function processAnimationQueue() {
            // If already playing an animation, wait
            if (gameState.mascotAnimationPlaying) {
                return;
            }

            // If queue is empty, return to idle
            if (gameState.mascotAnimationQueue.length === 0) {
                gameState.mascotAnimationPlaying = false;
                setMascotAnimation('idle');
                return;
            }

            // Play next animation in queue
            const nextAnimation = gameState.mascotAnimationQueue.shift();
            gameState.mascotAnimationPlaying = true;
            
            setMascotAnimation(nextAnimation);
            
            // Wait for animation to complete, then process next
            detectAnimationEnd(nextAnimation, () => {
                gameState.mascotAnimationPlaying = false;
                
                // Clear sad animation flag when sad animation completes
                if (nextAnimation === 'sad') {
                    gameState.sadAnimationActive = false;
                }
                
                processAnimationQueue();
            });
        }

        function detectAnimationEnd(animationType, callback) {
            // Use exact durations for GIF animations
            let estimatedDuration;
            switch(animationType) {
                case 'rally': 
                    estimatedDuration = 2000; // 2 seconds
                    break;
                case 'sad': 
                    estimatedDuration = 10800; // 10.8 seconds
                    break;
                case 'celebrate':
                    estimatedDuration = 2000; // 2 seconds
                    break;
                case 'ouch':
                    estimatedDuration = 1000; // 1 seconds
                    break;
                default: 
                    estimatedDuration = 3000; // 3 seconds default
            }
            
            setTimeout(callback, estimatedDuration);
        }

        function playMascotRally() {
            queueMascotAnimation('rally');
        }

        function playMascotSad() {
            queueMascotAnimation('sad');
        }

        function playMascotCelebrate() {
            queueMascotAnimation('celebrate');
        }

        function playMascotOuch() {
            queueMascotAnimation('ouch');
        }

        function updateMascotIcon() {
            // Mascot position is fixed, no need to reposition constantly
            // Play rally animation ONLY on new streak milestones
            if (gameState.streakCount > 0 && (gameState.streakCount === 3 || (gameState.streakCount > 3 && gameState.streakCount % 5 === 0))) {
                playMascotRally();
            }
        }

        function positionMascotIcon() {
            // No positioning needed - mascot uses CSS positioning inside charactersRow
        }

        function handleCorrectAnswer(word, button, optionIndex) {
            playSound('correct');
            button.classList.add('correct-animation');
            
            const progress = gameState.wordProgress[word.chinese];
            progress.count++;
            
            // Check for tier progression
            let tierChanged = false;
            const req = gameState.tierRequirement;
            
            if (progress.count === req && progress.tier === 'bronze') {
                progress.tier = 'silver';
                tierChanged = true;
            } else if (progress.count === req * 2 && progress.tier === 'silver') {
                progress.tier = 'gold';
                tierChanged = true;
            } else if (progress.count === req * 3 && progress.tier === 'gold') {
                // Word completed - add star and replace with new word IMMEDIATELY
                createStarAnimation(button);
                playStarShootAnimation();
                playSound('starShoot');
                playMascotCelebrate(); // Play celebrate animation when earning a star
                
                // IMMEDIATELY reset button to bronze and replace word
                addNewWordToRotation(word, optionIndex);
                
                gameState.starsEarned++;
                gameState.completedWords++;
                updateUI();
                
                if (gameState.completedWords === gameState.selectedWords.length) {
                    setTimeout(() => alert('Congratulations! You completed all words!'), 1000);
                    return;
                }
                
                // Don't call updateOptionButton since we've already replaced the word
                removeActiveCharacterAndAdvance();
                setTimeout(() => button.classList.remove('correct-animation'), 800);
                return;
            }
            
            // Play tier up animation and sound
            if (tierChanged) {
                button.classList.add('tier-up');
                playSound('tierUp');
                setTimeout(() => button.classList.remove('tier-up'), 800);
            }
            
            updateOptionButton(optionIndex, word, progress);
            removeActiveCharacterAndAdvance();
            
            setTimeout(() => button.classList.remove('correct-animation'), 800);
        }

        function playStarShootAnimation() {
            const starIcon = document.getElementById('starIcon');
            starIcon.classList.add('star-shoot');
            setTimeout(() => starIcon.classList.remove('star-shoot'), 1200);
        }

        function handleIncorrectAnswer(correctWord, selectedOptionIndex) {
            // Only penalize if NOT in easy mode
            if (!gameState.easyMode) {
                // Penalize the CORRECT word's button, not the selected one
                if (gameState.alreadyPenalized) return; // Only penalize once per character
                
                gameState.alreadyPenalized = true;
                
                // Find the correct word's button
                let correctOptionIndex = -1;
                for (let i = 0; i < gameState.currentOptions.length; i++) {
                    if (gameState.currentOptions[i] && gameState.currentOptions[i].chinese === correctWord.chinese) {
                        correctOptionIndex = i;
                        break;
                    }
                }
                
                if (correctOptionIndex !== -1) {
                    const progress = gameState.wordProgress[correctWord.chinese];
                    const oldTier = progress.tier; // Store old tier
                    
                    // Demote tier
                    if (progress.tier === 'gold') {
                        progress.tier = 'silver';
                    } else if (progress.tier === 'silver') {
                        progress.tier = 'bronze';
                    }
                    // Bronze stays bronze (can't go lower)
                    
                    // Play appropriate animation based on tier change
                    if (oldTier !== progress.tier) {
                        // Tier was demoted - play sad animation
                        console.log(`Tier demoted from ${oldTier} to ${progress.tier} - playing sad animation`);
                        playMascotSad();
                    } else if (progress.tier === 'bronze') {
                        // Wrong answer on bronze (no tier loss) - play ouch animation
                        console.log('Wrong answer on bronze tier - playing ouch animation');
                        playMascotOuch();
                    }
                    
                    updateOptionButton(correctOptionIndex, correctWord, progress);
                }
            } else {
                // Easy mode - just play ouch for any wrong answer (no tier loss)
                playMascotOuch();
            }
            
            playSound('incorrect');
        }

        function highlightCorrectAnswer(correctWord) {
            console.log('=== HIGHLIGHT CORRECT ANSWER DEBUG ===');
            
            // Find the correct answer button based on the CURRENT active character
            const activeCharacter = gameState.charactersOnScreen[gameState.activeWordIndex];
            if (!activeCharacter) {
                console.error('No active character found at index:', gameState.activeWordIndex);
                return;
            }
            
            const activeWordChinese = activeCharacter.word.chinese;
            console.log('Active word (should shake):', activeWordChinese, activeCharacter.word.english);
            console.log('Active word index:', gameState.activeWordIndex);
            console.log('Characters on screen:', gameState.charactersOnScreen.map((c, i) => ({
                index: i,
                chinese: c.word.chinese,
                english: c.word.english,
                isActive: i === gameState.activeWordIndex
            })));
            console.log('Current options:', gameState.currentOptions.map((o, i) => ({
                index: i,
                chinese: o?.chinese || 'null',
                english: o?.english || 'null'
            })));
            
            // Find the button that corresponds to the active character
            let foundCorrectButton = false;
            gameState.optionButtons.forEach((button, index) => {
                const option = gameState.currentOptions[index];
                if (option && option.chinese === activeWordChinese) {
                    console.log(`Found correct button at index ${index}:`, option.chinese, option.english);
                    
                    // Add both shake animation and highlight border
                    button.classList.add('shake-animation');
                    button.style.border = '3px solid var(--sunglow)';
                    button.style.boxShadow = '0 0 15px rgba(255, 203, 105, 0.6)';
                    
                    foundCorrectButton = true;
                    
                    // Remove shake animation after it completes
                    setTimeout(() => {
                        button.classList.remove('shake-animation');
                    }, 800);
                    
                    // Remove highlight after longer duration
                    setTimeout(() => {
                        button.style.border = '';
                        button.style.boxShadow = '';
                    }, 2000);
                }
            });
            
            if (!foundCorrectButton) {
                console.error('SHAKE ANIMATION BUG: Could not find correct button for word:', activeWordChinese);
                console.error('This suggests character-option synchronization is broken!');
            }
            
            console.log('=== END HIGHLIGHT DEBUG ===');
        }

        function updateOptionButton(optionIndex, word, progress) {
            const button = gameState.optionButtons[optionIndex];
            button.className = `option-btn tier-${progress.tier}`;
            
            const progressPercent = (progress.count % gameState.tierRequirement) * (100/gameState.tierRequirement);
            const progressFill = button.querySelector('.progress-fill');
            const progressCount = button.querySelector('.progress-count');
            
            if (progressFill) {
                progressFill.style.width = `${progressPercent}%`;
            }
            if (progressCount) {
                progressCount.textContent = `${progress.count}/${gameState.tierRequirement}`;
            }
        }

        function createStarAnimation(button) {
            // Create floating star animation
            const star = document.createElement('div');
            star.innerHTML = '‚≠ê';
            star.className = 'float-up';
            star.style.position = 'absolute';
            star.style.fontSize = '2rem';
            star.style.left = '50%';
            star.style.top = '50%';
            star.style.transform = 'translate(-50%, -50%)';
            star.style.pointerEvents = 'none';
            star.style.zIndex = '1000';
            
            button.style.position = 'relative';
            button.appendChild(star);
            
            setTimeout(() => {
                if (star.parentNode) star.parentNode.removeChild(star);
            }, 1000);
        }

        function addNewWordToRotation(completedWord, optionIndex) {
            // Find a new word that hasn't been completed yet
            const availableWords = gameState.selectedWords.filter(word => 
                gameState.wordProgress[word.chinese].count < gameState.tierRequirement * 3 &&
                !gameState.currentWords.some(w => w.chinese === word.chinese)
            );
            
            // Remove completed word from current rotation
            gameState.currentWords = gameState.currentWords.filter(word => 
                word.chinese !== completedWord.chinese
            );
            
            // Remove completed word from character rotation too
            removeCompletedWordFromCharacters(completedWord.chinese);
            
            // Add a new word if available
            if (availableWords.length > 0) {
                const newWord = availableWords[Math.floor(Math.random() * availableWords.length)];
                gameState.currentWords.push(newWord);
                
                // Replace the specific option button with new word (reset to bronze)
                gameState.currentOptions[optionIndex] = newWord;
                const progress = gameState.wordProgress[newWord.chinese];
                
                const button = gameState.optionButtons[optionIndex];
                button.classList.add('new-word-entry');
                button.className = 'option-btn tier-bronze new-word-entry';
                
                button.innerHTML = `
                    <span>${newWord.english}</span>
                    <div class="progress-count">${progress.count}/${gameState.tierRequirement}</div>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${(progress.count % gameState.tierRequirement) * (100/gameState.tierRequirement)}%"></div>
                    </div>
                    <div class="hotkey">${gameState.hotkeys[optionIndex]}</div>
                `;
                
                setTimeout(() => button.classList.remove('new-word-entry'), 800);
            } else {
                // No more words available for this slot
                gameState.currentOptions[optionIndex] = null;
                const button = gameState.optionButtons[optionIndex];
                button.className = 'option-btn tier-bronze';
                button.innerHTML = `
                    <span>COMPLETE</span>
                    <div class="hotkey">${gameState.hotkeys[optionIndex]}</div>
                `;
                button.style.opacity = '0.5';
            }
        }

        function removeCompletedWordFromCharacters(completedWordChinese) {
            // Remove all instances of the completed word from the character row
            gameState.charactersOnScreen = gameState.charactersOnScreen.filter(char => {
                if (char.word.chinese === completedWordChinese) {
                    char.element.classList.add('slide-left');
                    setTimeout(() => {
                        if (char.element.parentNode) {
                            char.element.parentNode.removeChild(char.element);
                        }
                    }, 500);
                    return false;
                }
                return true;
            });
            
            // Replenish character row
            while (gameState.charactersOnScreen.length < 8) {
                const word = getRandomCurrentWord();
                const container = document.createElement('div');
                container.className = 'character-container upcoming';
                container.innerHTML = `
                    <div class="pinyin">${word.pinyin}</div>
                    <div class="chinese-char">${getChineseChar(word)}</div>
                `;
                
                // Calculate container width based on content
                const chineseText = getChineseChar(word);
                const estimatedWidth = Math.max(120, chineseText.length * 30 + 40);
                container.style.width = `${estimatedWidth}px`;
                
                const charactersRow = document.getElementById('charactersRow');
                charactersRow.appendChild(container);
                gameState.charactersOnScreen.push({ element: container, word: word, width: estimatedWidth });
            }
            
            // Reposition all characters with proper spacing
            positionCharacterContainers();
            
            // Play pronunciation for new active character
            if (gameState.charactersOnScreen.length > 0) {
                setTimeout(() => playPronunciation(getChineseChar(gameState.charactersOnScreen[0].word)), 300);
            }
        }

        function removeActiveCharacterAndAdvance() {
            // Find and remove characters with the same word as active
            const activeChar = gameState.charactersOnScreen[gameState.activeWordIndex];
            if (!activeChar) return;
            
            const activeWord = activeChar.word;
            
            // Remove only the FIRST matching character (not all duplicates)
            let removedOne = false;
            gameState.charactersOnScreen.forEach(char => {
                if (char.word.chinese === activeWord.chinese && !removedOne) {
                    char.element.classList.add('slide-left');
                    setTimeout(() => {
                        if (char.element.parentNode) {
                            char.element.parentNode.removeChild(char.element);
                        }
                    }, 500);
                    removedOne = true;
                }
            });
            
            // Filter out only the first removed character
            let foundFirst = false;
            gameState.charactersOnScreen = gameState.charactersOnScreen.filter(char => {
                if (char.word.chinese === activeWord.chinese && !foundFirst) {
                    foundFirst = true;
                    return false; // Remove this one
                }
                return true; // Keep all others
            });
            
            // Maintain 8 characters by adding new ones
            while (gameState.charactersOnScreen.length < 8) {
                const word = getRandomCurrentWord();
                const container = document.createElement('div');
                container.className = 'character-container upcoming';
                container.innerHTML = `
                    <div class="pinyin">${word.pinyin}</div>
                    <div class="chinese-char">${getChineseChar(word)}</div>
                `;
                
                // Calculate container width based on content
                const chineseText = getChineseChar(word);
                const estimatedWidth = Math.max(120, chineseText.length * 30 + 40);
                container.style.width = `${estimatedWidth}px`;
                
                const charactersRow = document.getElementById('charactersRow');
                charactersRow.appendChild(container);
                gameState.charactersOnScreen.push({ element: container, word: word, width: estimatedWidth });
            }
            
            // Reposition all characters with proper spacing
            positionCharacterContainers();
            
            // Ensure mascot is in idle state (no positioning needed)
            setTimeout(() => {
                ensureMascotIdle();
            }, 100);
            
            // Play pronunciation for new active character
            if (gameState.charactersOnScreen.length > 0) {
                setTimeout(() => playPronunciation(getChineseChar(gameState.charactersOnScreen[0].word)), 300);
            }
        }

        function updateUI() {
            document.getElementById('starsCount').textContent = gameState.starsEarned;
        }

        // Settings Functions
        let listeningForInput = -1;
        
        function openSettings() {
            const modal = document.getElementById('settingsModal');
            const settingsContainer = document.getElementById('hotkeySettings');
            
            settingsContainer.innerHTML = '';
            
            gameState.hotkeys.forEach((key, index) => {
                const setting = document.createElement('div');
                setting.className = 'hotkey-setting';
                setting.innerHTML = `
                    <span>Button ${index + 1}:</span>
                    <input type="text" class="hotkey-input" value="${key}" readonly
                           onclick="startListening(${index})" 
                           placeholder="Click to set">
                `;
                settingsContainer.appendChild(setting);
            });
            
            modal.style.display = 'block';
        }
        
        function startListening(index) {
            listeningForInput = index;
            const input = document.querySelectorAll('.hotkey-input')[index];
            input.classList.add('listening');
            input.value = 'Press any key...';
            input.focus();
        }
        
        function closeSettings() {
            document.getElementById('settingsModal').style.display = 'none';
            listeningForInput = -1;
            setupOptionsGrid(); // Refresh to show new hotkeys
        }
        
        function updateHotkey(index, newKey) {
            if (newKey.length >= 1) {
                gameState.hotkeys[index] = newKey.toUpperCase();
                const input = document.querySelectorAll('.hotkey-input')[index];
                input.value = newKey.toUpperCase();
                input.classList.remove('listening');
                listeningForInput = -1;
            }
        }
        
        function returnToMenu() {
            // COMPREHENSIVE STATE CLEANUP
            console.log('=== STARTING COMPLETE STATE CLEANUP ===');
            
            // 1. STOP ALL AUDIO AND ANIMATIONS FIRST
            try {
                // Stop any playing audio
                const audioElements = document.querySelectorAll('audio');
                audioElements.forEach(audio => {
                    audio.pause();
                    audio.src = '';
                    audio.load();
                });
                
                // Remove any TTS audio element we created
                const ttsAudio = document.getElementById('tts-audio-element');
                if (ttsAudio) {
                    ttsAudio.pause();
                    ttsAudio.remove();
                }
                
                // Clear mascot animations
                gameState.mascotAnimationQueue = [];
                gameState.mascotAnimationPlaying = false;
                gameState.sadAnimationActive = false;
            } catch (error) {
                console.log('Audio cleanup error:', error);
            }
            
            // 2. CLEAN UP ALL DOM ELEMENTS AND ANIMATIONS
            try {
                // Clear all button animations and styles
                const optionsGrid = document.getElementById('optionsGrid');
                if (optionsGrid) {
                    const buttons = optionsGrid.querySelectorAll('.option-btn');
                    buttons.forEach(button => {
                        // Remove all animation classes
                        button.classList.remove('shake-animation', 'correct-animation', 'tier-up', 'new-word-entry', 'slide-left', 'float-up');
                        // Clear any inline styles
                        button.style.border = '';
                        button.style.boxShadow = '';
                        button.style.transform = '';
                        button.style.opacity = '';
                        // Remove event listeners by cloning the node
                        const newButton = button.cloneNode(true);
                        button.parentNode.replaceChild(newButton, button);
                    });
                    // Clear the entire grid
                    optionsGrid.innerHTML = '';
                }
                
                // Clear all character containers (except mascot)
                const charactersRow = document.getElementById('charactersRow');
                if (charactersRow) {
                    const characterContainers = charactersRow.querySelectorAll('.character-container:not(.mascot-container)');
                    characterContainers.forEach(container => {
                        container.classList.remove('active', 'next', 'upcoming', 'slide-left', 'new-word-entry');
                        container.style.left = '';
                        container.style.transform = '';
                        container.style.zIndex = '';
                        container.remove();
                    });
                }
                
                // Reset mascot to idle state
                const mascotImage = document.getElementById('mascotImage');
                if (mascotImage) {
                    mascotImage.src = 'Mascot/idle.gif?t=' + new Date().getTime();
                }
            } catch (error) {
                console.log('DOM cleanup error:', error);
            }
            
            // 3. COMPLETELY RESET GAME STATE
            const preservedSettings = {
                hotkeys: [...gameState.hotkeys], // Preserve hotkey settings
                easyMode: gameState.easyMode, // Preserve easy mode setting
                mascotAnimations: { ...gameState.mascotAnimations } // Preserve mascot animation paths
            };
            
            // Create completely fresh game state
            gameState = {
                // Core game data - all fresh
                selectedWords: [],
                currentWords: [],
                activeWordIndex: 0,
                wordProgress: {},
                starsEarned: 0,
                completedWords: 0,
                
                // UI state - all fresh
                charactersOnScreen: [],
                optionButtons: [],
                currentOptions: [],
                
                // Game mechanics - all fresh
                streakCount: 0,
                lastAnswerTime: 0,
                alreadyPenalized: false,
                tierRequirement: 5, // Reset to default
                
                // Preserved settings
                hotkeys: preservedSettings.hotkeys,
                easyMode: preservedSettings.easyMode,
                
                // Mascot state - reset to idle
                mascotAnimations: preservedSettings.mascotAnimations,
                mascotAnimationQueue: [],
                currentMascotAnimation: 'idle',
                mascotAnimationPlaying: false,
                sadAnimationActive: false
            };
            
            // 4. CLEAR ANY REMAINING TIMEOUTS/INTERVALS
            // Clear any high-numbered timeout IDs (common technique for clearing unknown timeouts)
            for (let i = 1; i < 10000; i++) {
                clearTimeout(i);
                clearInterval(i);
            }
            
            // 5. RESET UI ELEMENTS
            try {
                // Reset toggle states to match gameState
                const easyModeToggle = document.getElementById('easyModeToggle');
                const easyModeToggleMobile = document.getElementById('easyModeToggleMobile');
                const traditionalToggle = document.getElementById('traditionalToggle');
                const traditionalToggleMobile = document.getElementById('traditionalToggleMobile');
                
                if (gameState.easyMode) {
                    easyModeToggle?.classList.add('active');
                    easyModeToggleMobile?.classList.add('active');
                } else {
                    easyModeToggle?.classList.remove('active');
                    easyModeToggleMobile?.classList.remove('active');
                }
                
                if (useTraditional) {
                    traditionalToggle?.classList.add('active');
                    traditionalToggleMobile?.classList.add('active');
                } else {
                    traditionalToggle?.classList.remove('active');
                    traditionalToggleMobile?.classList.remove('active');
                }
                
                // Close mobile menu
                const mobileMenu = document.getElementById('mobileMenu');
                if (mobileMenu) {
                    mobileMenu.classList.remove('active');
                }
            } catch (error) {
                console.log('UI reset error:', error);
            }
            
            console.log('=== STATE CLEANUP COMPLETE ===');
            console.log('New gameState:', {
                selectedWords: gameState.selectedWords.length,
                currentWords: gameState.currentWords.length,
                charactersOnScreen: gameState.charactersOnScreen.length,
                optionButtons: gameState.optionButtons.length,
                currentOptions: gameState.currentOptions.length,
                activeWordIndex: gameState.activeWordIndex
            });
            
            // 6. SWITCH TO LANDING PAGE
            document.getElementById('gamePage').style.display = 'none';
            document.getElementById('landingPage').style.display = 'flex';
            
            console.log('=== RETURNED TO MENU SUCCESSFULLY ===');
        }

        function toggleEasyMode() {
            gameState.easyMode = !gameState.easyMode;
            const toggle = document.getElementById('easyModeToggle');
            const toggleMobile = document.getElementById('easyModeToggleMobile');
            
            if (gameState.easyMode) {
                toggle.classList.add('active');
                toggleMobile.classList.add('active');
            } else {
                toggle.classList.remove('active');
                toggleMobile.classList.remove('active');
            }
        }

        function toggleTraditional() {
            useTraditional = !useTraditional;
            const toggle = document.getElementById('traditionalToggle');
            const toggleMobile = document.getElementById('traditionalToggleMobile');
            
            if (useTraditional) {
                toggle.classList.add('active');
                toggleMobile.classList.add('active');
            } else {
                toggle.classList.remove('active');
                toggleMobile.classList.remove('active');
            }
            
            // Update all visible characters in real-time
            updateCharacterDisplay();
        }

        function toggleMobileMenu() {
            const mobileMenu = document.getElementById('mobileMenu');
            mobileMenu.classList.toggle('active');
        }

        // Close mobile menu when clicking outside
        document.addEventListener('click', function(event) {
            const mobileMenu = document.getElementById('mobileMenu');
            const toggleButton = document.querySelector('.mobile-menu-toggle');
            
            if (mobileMenu && !mobileMenu.contains(event.target) && !toggleButton.contains(event.target)) {
                mobileMenu.classList.remove('active');
            }
        });

        function updateCharacterDisplay() {
            // Update characters row
            gameState.charactersOnScreen.forEach(char => {
                const chineseCharElement = char.element.querySelector('.chinese-char');
                if (chineseCharElement) {
                    chineseCharElement.textContent = getChineseChar(char.word);
                }
                
                // Recalculate container width if needed
                const chineseText = getChineseChar(char.word);
                const estimatedWidth = Math.max(120, chineseText.length * 30 + 40);
                char.width = estimatedWidth;
                char.element.style.width = `${estimatedWidth}px`;
            });
            
            // Reposition characters with new widths
            positionCharacterContainers();
        }

        // Keyboard Controls
        function setupKeyboardListeners() {
            document.addEventListener('keydown', (event) => {
                // Check if we're listening for hotkey input
                if (listeningForInput !== -1) {
                    event.preventDefault();
                    updateHotkey(listeningForInput, event.key);
                    return;
                }
                
                // Check if any modal is open
                if (document.getElementById('settingsModal').style.display === 'block') {
                    if (event.key === 'Escape') {
                        closeSettings();
                    }
                    return;
                }
                
                const pressedKey = event.key.toUpperCase();
                const optionIndex = gameState.hotkeys.indexOf(pressedKey);
                
                if (optionIndex !== -1) {
                    event.preventDefault();
                    selectOption(optionIndex);
                }
            });
        }

        // Band selection and word loading
        async function changeBand() {
            const bandSelector = document.getElementById('bandSelector');
            const selectedBand = parseInt(bandSelector.value);
            
            // Show loading message
            const startButtons = document.querySelectorAll('.start-button');
            startButtons.forEach(btn => {
                btn.disabled = true;
                btn.textContent = 'Loading...';
            });
            
            // Load the selected band
            const success = await loadHSKWords(selectedBand);
            
            // Re-enable buttons
            startButtons.forEach((btn, index) => {
                btn.disabled = false;
                btn.textContent = index === 0 ? 'Custom Selection' : `All Words (Band ${selectedBand})`;
            });
            
            if (success) {
                currentBand = selectedBand;
            } else {
                // Reset selector if loading failed
                bandSelector.value = currentBand;
                alert(`Failed to load Band ${selectedBand} wordlist. Using Band ${currentBand}.`);
            }
        }

        // Initialize the app
        async function initializeApp() {
            // Load Band 1 by default
            await loadHSKWords(1);
            updateRange();
            
            // No need to load voices since we're using Google TTS
            console.log('App initialized with Google TTS audio support');
        }

        // Initialize range values on page load
        updateRange();
        
        // Load default wordlist when page loads
        window.addEventListener('DOMContentLoaded', initializeApp);
    </script>
     <!-- Footer with vintage green background -->
    <footer class="bg-[#797d62] text-white py-4 border-t border-gray-700 mt-auto">
        <div class="container mx-auto px-4 flex flex-col sm:flex-row justify-between items-center">
            <!-- Left aligned content (Patreon and GitHub) -->
            <div class="flex flex-col sm:items-start items-center mb-2 sm:mb-0">
                <p class="text-sm mb-1 rounded-md flex items-center">
                    <i class="fab fa-patreon text-lg mr-2"></i> <!-- Patreon Icon -->
                    Patreon:
                    <a href="https://www.patreon.com/UnfinishedProjects" target="_blank" rel="noopener noreferrer" class="text-blue-100 hover:underline font-medium rounded-md px-2 py-1 transition duration-300 ease-in-out">
                        @UnfinishedProjects
                    </a>
                </p>
                <p class="text-sm rounded-md flex items-center">
                    <i class="fab fa-github text-lg mr-2"></i> <!-- GitHub Icon -->
                    GitHub Repository:
                    <a href="https://github.com/GreenAnts/HSK-3.0-Study-Game" target="_blank" rel="noopener noreferrer" class="text-blue-100 hover:underline font-medium rounded-md px-2 py-1 transition duration-300 ease-in-out">
                        HSK-3.0-Study-Game
                    </a>
                </p>
            </div>

            <!-- Right aligned content (Mascot Attribution) -->
            <div class="flex flex-col sm:items-end items-center">
                <p class="text-sm rounded-md flex items-center">
                    <i class="fas fa-palette text-lg mr-2"></i> <!-- Palette Icon for Itch.io (Art Attribution) -->
                    Mascot Attribution:
                    <a href="https://atari-boy.itch.io/" target="_blank" rel="noopener noreferrer" class="text-blue-100 hover:underline font-medium rounded-md px-2 py-1 transition duration-300 ease-in-out">
                        Atari Boy
                    </a>
                </p>
            </div>
        </div>
    </footer>
</body>
</html>
