<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Piece Rendering Debug</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .canvas-container {
            border: 2px solid #333;
            margin: 10px 0;
            display: inline-block;
        }
        .piece-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .piece-test {
            border: 1px solid #ccc;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
        }
        .success { color: #155724; background: #d4edda; }
        .error { color: #721c24; background: #f8d7da; }
        .info { color: #0c5460; background: #d1ecf1; }
        button {
            padding: 8px 16px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            background: #007bff;
            color: white;
            cursor: pointer;
        }
        button:hover { background: #0056b3; }
        .log {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }

        /* Navigation Bar Styles */
        .nav-bar {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 15px 0;
            border-bottom: 1px solid #e9ecef;
        }

        .nav-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 30px;
        }

        .nav-left, .nav-right {
            flex: 1;
        }

        .nav-center {
            flex: 2;
            text-align: center;
        }

        .nav-center h2 {
            margin: 0;
            font-size: 1.5rem;
            font-weight: 300;
        }

        .nav-link {
            color: white;
            text-decoration: none;
            padding: 8px 16px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            font-size: 14px;
            font-weight: 500;
        }

        .nav-link:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        .nav-right {
            text-align: right;
        }
    </style>
</head>
<body>
    <!-- Navigation Bar -->
    <div class="nav-bar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="../unified-test-navigation.html" class="nav-link">
                    üè† Back to Test Hub
                </a>
            </div>
            <div class="nav-center">
                <h2>‚ôüÔ∏è Piece Debug Tests</h2>
            </div>
            <div class="nav-right">
                <a href="../../index.html" class="nav-link">
                    üéÆ Back to Game
                </a>
            </div>
        </div>
    </div>

    <div class="container">
        <h1>üéØ Piece Rendering Debug Tool</h1>
        <p>This tool tests all piece rendering functionality to ensure pieces display correctly on the board.</p>
        
        <div class="test-section">
            <h2>üìä Test Results</h2>
            <div id="results"></div>
        </div>
        
        <div class="test-section">
            <h2>üé® Piece Rendering Tests</h2>
            <button onclick="testAllPieces()">Test All Pieces</button>
            <button onclick="testIndividualPieces()">Test Individual Pieces</button>
            <button onclick="testPrePlacedPieces()">Test Pre-Placed Pieces</button>
            <button onclick="clearResults()">Clear Results</button>
        </div>
        
        <div class="test-section">
            <h2>üéÆ Game Board Test</h2>
            <div id="game-board-container" class="canvas-container">
                <h4>Game Board with Pre-Placed Pieces</h4>
            </div>
        </div>
        
        <div class="test-section">
            <h2>üìù Debug Log</h2>
            <button onclick="copyDebugLog()" class="copy-btn">üìã Copy Debug Log</button>
            <div id="debug-log" class="log"></div>
        </div>
    </div>

    <script type="module">
        const results = document.getElementById('results');
        const debugLog = document.getElementById('debug-log');
        const gameBoardContainer = document.getElementById('game-board-container');
        
        function log(message, type = 'info', data = null) {
            const timestamp = new Date().toLocaleTimeString();
            let logEntry = `[${timestamp}] ${message}`;
            
            if (data && Object.keys(data).length > 0) {
                // Only include essential data for token conservation
                const essentialData = {};
                Object.keys(data).slice(0, 2).forEach(key => {
                    if (typeof data[key] === 'number' || typeof data[key] === 'string') {
                        essentialData[key] = data[key];
                    }
                });
                if (Object.keys(essentialData).length > 0) {
                    logEntry += ` | ${JSON.stringify(essentialData)}`;
                }
            }
            
            debugLog.innerHTML += `<div class="${type}">${logEntry}</div>`;
            debugLog.scrollTop = debugLog.scrollHeight;
            console.log(logEntry);
        }
        
        function addResult(test, status, message, data = null) {
            const div = document.createElement('div');
            div.className = `test-section ${status}`;
            
            const dataText = data ? JSON.stringify(data, null, 2) : '';
            const fullText = `${test}: ${status.toUpperCase()} - ${message}\n${dataText}`;
            
            div.innerHTML = `
                <h3>${test}</h3>
                <p><strong>Status:</strong> ${status.toUpperCase()}</p>
                <p><strong>Message:</strong> ${message}</p>
                ${data ? `<pre>${dataText}</pre>` : ''}
                <button onclick="copyToClipboard('${fullText.replace(/'/g, "\\'").replace(/\n/g, '\\n')}')" class="copy-btn">üìã Copy Result</button>
            `;
            results.appendChild(div);
        }
        
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                log('Copied to clipboard!', 'success');
            }).catch(err => {
                log('Failed to copy: ' + err, 'error');
            });
        }
        
        function copyDebugLog() {
            const logText = debugLog.innerText;
            copyToClipboard(logText);
        }
        
        async function testAllPieces() {
            try {
                log('Starting comprehensive piece rendering test...');
                
                // Load modules
                const { createGameCanvas } = await import('../../ui/graphics.js');
                const { createBoard, createInitialState } = await import('../../core/board.js');
                
                // Load data with better error handling
                log('Loading board data...');
                const boardResponse = await fetch('../../data/board-data.json');
                if (!boardResponse.ok) {
                    throw new Error(`HTTP ${boardResponse.status}: ${boardResponse.statusText}`);
                }
                
                const boardText = await boardResponse.text();
                log(`Board data response length: ${boardText.length}`);
                
                if (!boardText || boardText.trim() === '') {
                    throw new Error('Empty response received for board data');
                }
                
                const boardData = JSON.parse(boardText);
                log('Board data parsed successfully');
                
                // Create board and state
                const board = createBoard(boardData);
                const state = createInitialState(board, boardData);
                
                log(`Board created with ${board.intersections.length} intersections`);
                log(`State created with ${Object.keys(state.pieces).length} pieces`);
                
                // Create canvas
                const canvasContext = createGameCanvas(gameBoardContainer, boardData);
                
                // Draw board
                canvasContext.drawBoard();
                log('Board drawn successfully');
                
                // Check if pieces exist
                const pieceCount = Object.keys(state.pieces).length;
                if (pieceCount === 0) {
                    throw new Error('No pieces found in initial state');
                }
                
                // Draw pieces
                const piecesForCanvas = {};
                for (const [pieceId, piece] of Object.entries(state.pieces)) {
                    const coordStr = `${piece.coords[0]},${piece.coords[1]}`;
                    piecesForCanvas[coordStr] = {
                        type: piece.type,
                        size: 12,
                        colors: ['#E63960', '#A9E886', '#F8F6DA', '#F6C13F'],
                        rotation: 0,
                        outerColor: '#0066CC',
                        innerColor: '#FFFFFF'
                    };
                }
                
                canvasContext.drawPieces(piecesForCanvas, null);
                log(`Drew ${Object.keys(piecesForCanvas).length} pieces`);
                
                // Test results
                const visiblePieces = Object.keys(piecesForCanvas).length;
                
                addResult('Piece Rendering Test', 'success', 
                    `Successfully rendered ${visiblePieces} pieces on the board`, {
                        totalPieces: pieceCount,
                        visiblePieces: visiblePieces,
                        pieceTypes: Object.values(state.pieces).map(p => p.type),
                        pieceCoords: Object.values(state.pieces).map(p => p.coords)
                    });
                
                log('Piece rendering test completed successfully');
                
            } catch (error) {
                log(`Error in piece rendering test: ${error.message}`, 'error');
                addResult('Piece Rendering Test', 'error', error.message);
            }
        }
        
        async function testIndividualPieces() {
            try {
                log('Testing individual piece types...');
                
                const { createGameCanvas } = await import('../../ui/graphics.js');
                
                log('Loading board data for individual piece test...');
                const boardResponse = await fetch('../../data/board-data.json');
                if (!boardResponse.ok) {
                    throw new Error(`HTTP ${boardResponse.status}: ${boardResponse.statusText}`);
                }
                
                const boardText = await boardResponse.text();
                if (!boardText || boardText.trim() === '') {
                    throw new Error('Empty response received for board data');
                }
                
                const boardData = JSON.parse(boardText);
                log('Board data loaded for individual piece test');
                
                const canvasContext = createGameCanvas(gameBoardContainer, boardData);
                canvasContext.drawBoard();
                
                // Test different piece types
                const testPieces = {
                    '0,0': {
                        type: 'amalgamCircle',
                        size: 12,
                        colors: ['#E63960', '#A9E886', '#F8F6DA', '#F6C13F'],
                        rotation: 0
                    },
                    '1,0': {
                        type: 'amalgamSquare',
                        size: 12,
                        colors: ['#E63960', '#A9E886', '#F8F6DA', '#F6C13F'],
                        rotation: 0
                    },
                    '0,1': {
                        type: 'voidCircle',
                        size: 12,
                        outerColor: '#000000',
                        innerColor: '#FFFFFF'
                    },
                    '1,1': {
                        type: 'voidSquare',
                        size: 12,
                        outerColor: '#000000',
                        innerColor: '#FFFFFF'
                    },
                    '0,-1': {
                        type: 'portalCircle',
                        size: 12,
                        outerColor: '#FFD700',
                        innerColor: '#FFFFFF'
                    },
                    '-1,0': {
                        type: 'portalSquare',
                        size: 12,
                        outerColor: '#FFD700',
                        innerColor: '#FFFFFF'
                    }
                };
                
                canvasContext.drawPieces(testPieces, null);
                
                addResult('Individual Piece Test', 'success', 
                    'Successfully rendered all piece types', {
                        pieceTypes: Object.values(testPieces).map(p => p.type),
                        pieceCount: Object.keys(testPieces).length
                    });
                
                log('Individual piece test completed');
                
            } catch (error) {
                log(`Error in individual piece test: ${error.message}`, 'error');
                addResult('Individual Piece Test', 'error', error.message);
            }
        }
        
        async function testPrePlacedPieces() {
            try {
                log('Testing pre-placed pieces...');
                
                const { createBoard, createInitialState } = await import('../../core/board.js');
                
                log('Loading board data for pre-placed pieces test...');
                const boardResponse = await fetch('../../data/board-data.json');
                if (!boardResponse.ok) {
                    throw new Error(`HTTP ${boardResponse.status}: ${boardResponse.statusText}`);
                }
                
                const boardText = await boardResponse.text();
                if (!boardText || boardText.trim() === '') {
                    throw new Error('Empty response received for board data');
                }
                
                const boardData = JSON.parse(boardText);
                log('Board data loaded for pre-placed pieces test');
                
                const board = createBoard(boardData);
                const state = createInitialState(board, boardData);
                
                const prePlacedPieces = Object.values(state.pieces).filter(p => p.isPrePlaced);
                
                if (prePlacedPieces.length === 0) {
                    throw new Error('No pre-placed pieces found');
                }
                
                addResult('Pre-Placed Pieces Test', 'success', 
                    `Found ${prePlacedPieces.length} pre-placed pieces`, {
                        pieces: prePlacedPieces.map(p => ({
                            id: p.id,
                            type: p.type,
                            coords: p.coords,
                            isPrePlaced: p.isPrePlaced
                        }))
                    });
                
                log(`Found ${prePlacedPieces.length} pre-placed pieces`);
                
            } catch (error) {
                log(`Error in pre-placed pieces test: ${error.message}`, 'error');
                addResult('Pre-Placed Pieces Test', 'error', error.message);
            }
        }
        
        function clearResults() {
            results.innerHTML = '';
            debugLog.innerHTML = '';
            gameBoardContainer.innerHTML = '<h4>Game Board with Pre-Placed Pieces</h4>';
        }
        
        // Make functions globally available
        window.testAllPieces = testAllPieces;
        window.testIndividualPieces = testIndividualPieces;
        window.testPrePlacedPieces = testPrePlacedPieces;
        window.clearResults = clearResults;
        window.copyToClipboard = copyToClipboard;
        window.copyDebugLog = copyDebugLog;
        
        // Auto-run basic test on load
        window.addEventListener('load', () => {
            log('Piece rendering debug tool loaded');
            testPrePlacedPieces();
        });
    </script>
</body>
</html>

