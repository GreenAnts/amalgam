<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Amalgam Unified Test Suite</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .test-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        .test-section {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
        }
        .controls {
            text-align: center;
            margin: 20px 0;
        }
        .debug-output {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .canvas-area {
            border: 2px solid #333;
            margin: 15px 0;
            min-height: 200px;
            position: relative;
        }
        .canvas-area h4 {
            position: absolute;
            top: 5px;
            left: 10px;
            background: rgba(255,255,255,0.9);
            padding: 5px 10px;
            border-radius: 4px;
            margin: 0;
            font-size: 12px;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            background: #007bff;
            color: white;
            cursor: pointer;
            font-weight: 500;
        }
        button:hover { background: #0056b3; }
        button:disabled { background: #6c757d; cursor: not-allowed; }
        .primary-btn { background: #28a745; font-size: 16px; font-weight: bold; }
        .primary-btn:hover { background: #218838; }
        .copy-btn { 
            background: #17a2b8; 
            position: relative;
            margin-left: 10px;
        }
        .copy-btn:hover { background: #138496; }
        .success { color: #155724; background: #d4edda; padding: 10px; border-radius: 4px; margin: 5px 0; }
        .error { color: #721c24; background: #f8d7da; padding: 10px; border-radius: 4px; margin: 5px 0; }
        .navigation { 
            text-align: center; 
            margin-top: 20px; 
            padding-top: 20px; 
            border-top: 1px solid #e9ecef; 
        }
        .navigation a { 
            color: #007bff; 
            text-decoration: none; 
            margin: 0 15px; 
        }
        .navigation a:hover { text-decoration: underline; }
        .output-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        .output-header h4 {
            margin: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üß™ Amalgam Unified Test Suite</h1>
            <p>Comprehensive testing, debugging, and visual validation in one place</p>
        </div>
        
        <div class="controls">
            <button class="primary-btn" onclick="runAllTests()">üöÄ Run All Tests</button>
            <button onclick="clearResults()">üóëÔ∏è Clear Results</button>
            <button onclick="testMainPageIssue()">üîç Debug Main Page Issue</button>
            <button onclick="visualPieceTest()">üëæ Visual Piece Test</button>
        </div>
        
        <div class="test-grid">
            <div class="test-section">
                <div class="output-header">
                    <h4>üìä Test Results</h4>
                    <button class="copy-btn" onclick="copyResults()">üìã Copy Results</button>
                </div>
                <div id="test-results" class="debug-output"></div>
            </div>
            
            <div class="test-section">
                <div class="output-header">
                    <h4>üîç Debug Output</h4>
                    <button class="copy-btn" onclick="copyDebugOutput()">üìã Copy Debug Log</button>
                </div>
                <div id="debug-output" class="debug-output"></div>
            </div>
        </div>
        
        <div class="test-section">
            <h4>üé® Visual Tests</h4>
            <div id="canvas-container" class="canvas-area">
                <h4>Canvas will appear here after running visual tests</h4>
            </div>
        </div>
        
        <div class="navigation">
            <a href="index.html">‚Üê Main Game</a> |
            <a href="tests/index.html">üß™ Testing Hub</a> |
            <a href="debug/index.html">üîç Debug Hub</a> |
            <a href="README.md" target="_blank">üìö Documentation</a>
        </div>
    </div>

    <script type="module">
        const cacheBust = Date.now();
        let testResults = [];
        
        function log(message, data = null) {
            const debugDiv = document.getElementById('debug-output');
            const timestamp = new Date().toLocaleTimeString();
            let logEntry = `[${timestamp}] ${message}`;
            if (data) {
                logEntry += '\n' + JSON.stringify(data, null, 2);
            }
            debugDiv.innerHTML += logEntry + '\n\n';
            debugDiv.scrollTop = debugDiv.scrollHeight;
            console.log(message, data);
        }

        function addResult(testName, success, message, data = null) {
            const resultsDiv = document.getElementById('test-results');
            const status = success ? '‚úÖ PASS' : '‚ùå FAIL';
            const className = success ? 'success' : 'error';
            
            let result = `<div class="${className}"><strong>${status}: ${testName}</strong><br/>${message}`;
            if (data) {
                result += `<br/><small>${JSON.stringify(data, null, 2)}</small>`;
            }
            result += '</div>';
            
            resultsDiv.innerHTML += result;
            testResults.push({ testName, success, message, data });
            log(`${testName}: ${success ? 'PASS' : 'FAIL'} - ${message}`, data);
        }

        window.clearResults = function() {
            document.getElementById('test-results').innerHTML = '';
            document.getElementById('debug-output').innerHTML = '';
            document.getElementById('canvas-container').innerHTML = '<h4>Canvas will appear here after running visual tests</h4>';
            testResults = [];
        };

        window.copyResults = async function() {
            const resultsDiv = document.getElementById('test-results');
            const text = resultsDiv.innerText || resultsDiv.textContent;
            await copyToClipboard(text, 'Test results copied to clipboard!');
        };

        window.copyDebugOutput = async function() {
            const debugDiv = document.getElementById('debug-output');
            const text = debugDiv.innerText || debugDiv.textContent;
            await copyToClipboard(text, 'Debug output copied to clipboard!');
        };

        async function copyToClipboard(text, successMessage) {
            try {
                await navigator.clipboard.writeText(text);
                log(successMessage);
            } catch (err) {
                // Fallback
                const textArea = document.createElement('textarea');
                textArea.value = text;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                log(successMessage + ' (fallback)');
            }
        }

        async function testDataLoading() {
            try {
                const boardResponse = await fetch(`.../data/board-data.json?v=${cacheBust}`);
                const boardData = await boardResponse.json();
                
                const pieceResponse = await fetch(`.../data/piece-definitions.json?v=${cacheBust}`);
                const pieceDefs = await pieceResponse.json();
                
                addResult('Data Loading', true, `Board schema: ${boardData.schema}, Pieces loaded`, {
                    boardSchema: boardData.schema,
                    pieceTypes: Object.keys(pieceDefs.piece_definitions).length
                });
                
                return { boardData, pieceDefs };
                
            } catch (error) {
                addResult('Data Loading', false, error.message);
                throw error;
            }
        }

        async function testBoardGeneration(boardData) {
            try {
                const { createBoard } = await import(`.../core/board.js?v=${cacheBust}`);
                const board = createBoard(boardData);
                
                if (!board.intersections || !Array.isArray(board.intersections)) {
                    throw new Error('Board missing intersections array');
                }
                
                // Fix the missing goldenLineConnections issue
                if (!board.goldenLineConnections) {
                    addResult('Board Generation', false, 'Board missing goldenLineConnections array');
                    return board;
                }
                
                addResult('Board Generation', true, `Board created with ${board.intersections.length} intersections`, {
                    intersections: board.intersections.length,
                    goldenConnections: board.goldenLineConnections?.length || 0
                });
                
                return board;
                
            } catch (error) {
                addResult('Board Generation', false, error.message);
                throw error;
            }
        }

        async function testGameState(board) {
            try {
                const { createInitialState } = await import(`.../core/board.js?v=${cacheBust}`);
                const state = createInitialState(board);
                
                const pieceCount = Object.keys(state.pieces).length;
                
                addResult('Game State', true, `Game initialized with ${pieceCount} pieces`, {
                    gamePhase: state.gamePhase,
                    currentPlayer: state.currentPlayer,
                    pieceCount
                });
                
                return state;
                
            } catch (error) {
                addResult('Game State', false, error.message);
                throw error;
            }
        }

        async function testCanvasCreation(boardData) {
            try {
                const { createGameCanvas } = await import(`.../ui/graphics.js?v=${cacheBust}`);
                
                // Clear and setup canvas container
                const container = document.getElementById('canvas-container');
                container.innerHTML = '';
                
                const testDiv = document.createElement('div');
                testDiv.style.border = '1px solid #ccc';
                testDiv.style.margin = '10px';
                testDiv.innerHTML = '<h4>Main Game Canvas Simulation</h4>';
                container.appendChild(testDiv);
                
                const gameCanvas = createGameCanvas(testDiv, boardData);
                
                addResult('Canvas Creation', true, `Canvas created ${gameCanvas.canvas.width}x${gameCanvas.canvas.height}`, {
                    width: gameCanvas.canvas.width,
                    height: gameCanvas.canvas.height,
                    boardDictSize: Object.keys(gameCanvas.boardDict).length
                });
                
                return gameCanvas;
                
            } catch (error) {
                addResult('Canvas Creation', false, error.message);
                throw error;
            }
        }

        window.testMainPageIssue = async function() {
            try {
                log('üîç Debugging main page rendering issue...');
                
                const { boardData } = await testDataLoading();
                const gameCanvas = await testCanvasCreation(boardData);
                
                // Test 1: Just draw board
                log('Test 1: Drawing board only');
                gameCanvas.drawBoard();
                
                // Check what was drawn
                const imageData1 = gameCanvas.ctx.getImageData(0, 0, gameCanvas.canvas.width, gameCanvas.canvas.height);
                let nonWhitePixels1 = 0;
                for (let i = 0; i < imageData1.data.length; i += 4) {
                    if (imageData1.data[i] !== 255 || imageData1.data[i+1] !== 255 || imageData1.data[i+2] !== 255) {
                        nonWhitePixels1++;
                    }
                }
                
                log(`After drawBoard(): ${nonWhitePixels1} non-white pixels`);
                
                // Test 2: Check board dictionary
                const boardDict = gameCanvas.boardDict;
                const standardCount = Object.values(boardDict).filter(type => type === 'standard').length;
                const goldenCount = Object.values(boardDict).filter(type => type === 'golden').length;
                
                log('Board dictionary:', { 
                    total: Object.keys(boardDict).length,
                    standard: standardCount,
                    golden: goldenCount,
                    sampleStandard: Object.entries(boardDict).filter(([k,v]) => v === 'standard').slice(0, 3),
                    sampleGolden: Object.entries(boardDict).filter(([k,v]) => v === 'golden').slice(0, 3)
                });
                
                if (standardCount === 0) {
                    addResult('Main Page Debug', false, 'No standard intersections found in board dictionary!');
                } else if (nonWhitePixels1 === 0) {
                    addResult('Main Page Debug', false, 'Board drawing produced no visible output!');
                } else {
                    addResult('Main Page Debug', true, `Board rendered with ${standardCount} standard intersections`);
                }
                
            } catch (error) {
                addResult('Main Page Debug', false, error.message);
                log('Debug error:', error);
            }
        };

        window.visualPieceTest = async function() {
            try {
                log('üëæ Running visual piece test...');
                
                const { boardData } = await testDataLoading();
                const board = await testBoardGeneration(boardData);
                const state = await testGameState(board);
                const gameCanvas = await testCanvasCreation(boardData);
                
                // Draw board first
                gameCanvas.drawBoard();
                
                // Convert and draw pieces
                const piecesForCanvas = {};
                for (const [pieceId, piece] of Object.entries(state.pieces)) {
                    const coordStr = `${piece.coords[0]},${piece.coords[1]}`;
                    
                    // Use proper piece type mapping
                    let canvasType = 'amalgamCircle';
                    if (piece.type === 'Amalgam') {
                        canvasType = piece.player === 'circles' ? 'amalgamCircle' : 'amalgamSquare';
                    } else if (piece.type === 'Void') {
                        canvasType = piece.player === 'circles' ? 'voidCircle' : 'voidSquare';
                    } else if (piece.type === 'Portal') {
                        canvasType = piece.player === 'circles' ? 'portalCircle' : 'portalSquare';
                    }
                    
                    piecesForCanvas[coordStr] = {
                        type: canvasType,
                        size: 12,
                        colors: ['#E63960', '#A9E886', '#F8F6DA', '#F6C13F'],
                        rotation: 0,
                        outerColor: piece.player === 'circles' ? '#0066CC' : '#CC0066',
                        innerColor: '#FFFFFF'
                    };
                }
                
                log('Pieces for canvas:', {
                    count: Object.keys(piecesForCanvas).length,
                    coordinates: Object.keys(piecesForCanvas),
                    samplePiece: Object.values(piecesForCanvas)[0]
                });
                
                // Draw pieces
                gameCanvas.drawPieces(piecesForCanvas, null);
                
                // Check if pieces are visible
                let visiblePieces = 0;
                for (const [coordStr] of Object.entries(piecesForCanvas)) {
                    const [x, y] = coordStr.split(',').map(Number);
                    const pixelX = gameCanvas.originX + x * 25;
                    const pixelY = gameCanvas.originY - y * 25;
                    
                    const imageData = gameCanvas.ctx.getImageData(pixelX, pixelY, 1, 1);
                    const [r, g, b] = imageData.data;
                    
                    if (r !== 255 || g !== 255 || b !== 255) {
                        visiblePieces++;
                    }
                }
                
                addResult('Visual Piece Test', visiblePieces > 0, 
                    `${visiblePieces}/${Object.keys(piecesForCanvas).length} pieces visible`,
                    { visiblePieces, totalPieces: Object.keys(piecesForCanvas).length }
                );
                
            } catch (error) {
                addResult('Visual Piece Test', false, error.message);
                log('Visual test error:', error);
            }
        };

        window.runAllTests = async function() {
            clearResults();
            log('üöÄ Starting unified test suite...');
            
            try {
                // Core tests
                const { boardData, pieceDefs } = await testDataLoading();
                const board = await testBoardGeneration(boardData);
                const state = await testGameState(board);
                const gameCanvas = await testCanvasCreation(boardData);
                
                // Additional tests
                await testMainPageIssue();
                await visualPieceTest();
                
                // Summary
                const passed = testResults.filter(r => r.success).length;
                const total = testResults.length;
                
                log(`üèÅ Test suite completed: ${passed}/${total} tests passed`);
                
                if (passed === total) {
                    addResult('Overall', true, `All ${total} tests passed! üéâ`);
                } else {
                    addResult('Overall', false, `${total - passed} tests failed`);
                }
                
            } catch (error) {
                addResult('Test Suite', false, `Test suite failed: ${error.message}`);
                log('Test suite error:', error);
            }
        };

        // Auto-ready message
        setTimeout(() => {
            log('üîß Unified test suite ready. Click "Run All Tests" to begin.');
        }, 1000);
    </script>
</body>
</html>
